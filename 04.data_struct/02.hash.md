# 哈希表 (Hash Table)

## 一、什么是哈希表

哈希表（Hash Table），也叫散列表，是一种基于 key-value 存储的数据结构。通过哈希
函数将 key 映射到存储位置，实现 O(1) 时间复杂度的查找、插入和删除操作。

### 基本原理

```
┌─────────────────────────────────────────────┐
│                  Hash Table                 │
├─────────────────────────────────────────────┤
│  bucket[0] → [key1:value1] → [key2:value2]  │  ← 可能发生冲突
│  bucket[1] → NULL                           │
│  bucket[2] → [key3:value3]                  │
│  ...                                        │
└─────────────────────────────────────────────┘

index = hash_function(key) % bucket_size
```

### 哈希冲突解决

Linux 内核使用**链地址法（Chaining）**解决冲突，即每个 bucket 指向一个链表（hlist）。

```
冲突示例：
key1 = "abc"  → hash = 5
key2 = "xyz"  → hash = 5  (冲突!)

bucket[5] → [key1:value1] → [key2:value2] → NULL
```

---

## 二、Linux 内核哈希表 API

内核提供了两种哈希表实现：
1. **固定大小哈希表** - `DEFINE_HASHTABLE`
2. **动态大小哈希表** - 使用 IDR/XArray（见后续文档）

### 2.1 定义哈希表

```c
#include <linux/hashtable.h>

// 静态定义哈希表，16 个 bucket (2^4)
DEFINE_HASHTABLE(name, 4);  // name 是哈希表变量名，4 是 order (2^4=16)

// 等价于
DECLARE_HASHTABLE(name, 4);
```

底层实现：
```c
#define DEFINE_HASHTABLE(name, bits)                     \
    struct hlist_head name[1 << (bits)] =               \
            { [0 ... ((1 << (bits)) - 1)] = HLIST_HEAD_INIT }
```

### 2.2 初始化哈希表

```c
// 动态声明
DECLARE_HASHTABLE(hashtable, 4);  // 16 buckets

// 运行时初始化
hash_init(hashtable);
```

### 2.3 定义数据结构

```c
struct my_struct {
    int key;                // 哈希键
    char name[32];
    void *data;
    struct hlist_node node; // 必须包含此成员
    struct rcu_head rcu;    // 如果使用 RCU
};
```

### 2.4 添加元素

```c
struct my_struct *obj;
unsigned int hash_key;

obj = kmalloc(sizeof(*obj), GFP_KERNEL);
if (!obj)
    return -ENOMEM;

obj->key = 42;
strscpy(obj->name, "test", sizeof(obj->name));
obj->data = some_data;

hash_key = obj->key;

// 添加到哈希表
hash_add(hashtable, &obj->node, hash_key);
```

### 2.5 查找元素

```c
struct my_struct *obj;
unsigned int hash_key = 42;

// 遍历指定 bucket 中的所有节点
hash_for_each_possible(hashtable, obj, node, hash_key) {
    if (obj->key == hash_key) {
        printk("Found: %s\n", obj->name);
        break;
    }
}
```

### 2.6 删除元素

```c
struct my_struct *obj;
unsigned int hash_key = 42;

// 先查找
hash_for_each_possible(hashtable, obj, node, hash_key) {
    if (obj->key == hash_key) {
        // 找到后删除
        hash_del(&obj->node);
        kfree(obj);
        break;
    }
}
```

### 2.7 遍历哈希表

```c
struct my_struct *obj;
int bkt;

// 遍历所有 bucket
hash_for_each(hashtable, bkt, obj, node) {
    printk("bucket[%d]: key=%d, name=%s\n", bkt, obj->key, obj->name);
}

// 安全遍历（支持删除）
struct my_struct *tmp;
hash_for_each_safe(hashtable, bkt, obj, tmp, node) {
    if (obj->key == target) {
        hash_del(&obj->node);
        kfree(obj);
    }
}
```

---

## 三、完整驱动示例

```c
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/hashtable.h>
#include <linux/string.h>

#define HASH_BITS 4  // 16 个 bucket

static DEFINE_HASHTABLE(test_hash, HASH_BITS);

struct test_node {
    int key;
    int value;
    struct hlist_node node;
};

static int __init hash_init_demo(void)
{
    struct test_node *node;
    struct test_node *tmp;
    int i;
    int bkt;

    // 添加元素
    for (i = 0; i < 10; i++) {
        node = kmalloc(sizeof(*node), GFP_KERNEL);
        if (!node)
            return -ENOMEM;

        node->key = i;
        node->value = i * 100;
        hash_add(test_hash, &node->node, node->key);
    }

    // 遍历打印
    hash_for_each(test_hash, bkt, node, node) {
        printk("bucket[%d]: key=%d, value=%d\n",
               bkt, node->key, node->value);
    }

    // 查找测试
    int search_key = 5;
    hash_for_each_possible(test_hash, node, node, search_key) {
        if (node->key == search_key) {
            printk("Found key %d: value=%d\n", node->key, node->value);
        }
    }

    return 0;
}

static void __exit hash_exit_demo(void)
{
    struct test_node *node;
    struct test_node *tmp;
    int bkt;

    // 清理所有节点
    hash_for_each_safe(test_hash, bkt, node, tmp, node) {
        hash_del(&node->node);
        kfree(node);
    }
}

module_init(hash_init_demo);
module_exit(hash_exit_demo);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Hash table demo driver");
```

---

## 四、内核中的实际应用

### 4.1 进程 PID 哈希表

```c
// kernel/pid.c - 通过 PID 快速查找进程
struct pid_namespace {
    struct idr idr;  // 底层使用 IDR（整数 ID 管理）
};

struct pid *find_pid_ns(int nr, struct pid_namespace *ns)
{
    return idr_find(&ns->idr, nr);
}
```

### 4.2 dentry cache（目录项缓存）

```c
// fs/dcache.c
static struct hlist_head *dentry_hashtable __read_mostly;

static inline unsigned long hash(const struct dentry *dentry,
                                 struct qstr *name)
{
    unsigned long hash = name->hash;
    // 哈希函数
    hash += ((unsigned long) dentry / L1_CACHE_BYTES);
    hash = hash + (hash >> HASH_SHIFT) + (hash << HASH_SHIFT);
    return hash;
}
```

### 4.3 inode cache

```c
// fs/inode.c
static struct hlist_head *inode_hashtable __read_mostly;

// 通过 inode 号查找
static struct inode *find_inode(struct super_block *sb,
                                unsigned long hashval,
                                struct inode *(*test)(struct inode *, void *),
                                void *data)
{
    struct hlist_head *head = inode_hashtable + hash(hashval);
    struct inode *inode;

    hlist_for_each_entry(inode, head, i_hash) {
        if (inode->i_sb != sb)
            continue;
        if (!test(inode, data))
            continue;
        return inode;
    }
    return NULL;
}
```

### 4.4 网络连接跟踪

```c
// net/netfilter/nf_conntrack_core.c
/* 哈希表大小可配置 */
static unsigned int nf_conntrack_htable_size __read_mostly;

static struct hlist_head *nf_conntrack_hash __read_mostly;

// 查找连接
static struct nf_conntrack_tuple_hash *
__nf_conntrack_find(struct net *net, const struct nf_conntrack_tuple *tuple)
{
    struct nf_conntrack_tuple_hash *h;
    struct hlist_nulls_node *n;
    unsigned int hash;

    hash = hash_net(net, tuple);
    hlist_nulls_for_each_entry_rcu(h, n, &nf_conntrack_hash[hash], hnnode) {
        if (nf_ct_tuple_equal(tuple, &h->tuple) &&
            net_eq(net, nf_ct_net(h->tuple)))
            return h;
    }
    return NULL;
}
```

---

## 五、哈希表使用场景

### 适合使用哈希表的场景

| 场景         | 说明                 | 内核示例               |
|--------------|----------------------|------------------------|
| **快速查找** | O(1) 时间复杂度      | PID 查找、inode 查找   |
| **键值存储** | 通过 key 找 value    | dentry cache、文件系统 |
| **去重**     | 快速判断元素是否存在 | 连接跟踪去重           |
| **计数统计** | 统计元素出现次数     | 网络包统计             |

### 不适合使用哈希表的情况

| 场景             | 原因                    | 替代方案               |
|------------------|-------------------------|------------------------|
| **需要有序遍历** | 哈希表无序              | 红黑树 (VMA、CFS 调度) |
| **key 范围查询** | 哈希表不支持范围查询    | 红黑树、基数树         |
| **内存受限**     | 哈希表空间开销较大      | 数组、链表             |
| **最坏性能敏感** | 哈希冲突可能退化为 O(n) | 平衡树                 |

---

## 六、性能优化技巧

### 6.1 选择合适的哈希表大小

```c
// 哈希表大小应该是 2 的幂，便于取模优化
#define HASH_BITS  8   // 256 buckets (适合小规模)
#define HASH_BITS  10  // 1024 buckets (中等规模)
#define HASH_BITS  16  // 65536 buckets (大规模)

// 取模优化：位运算代替除法
index = hash_key & (HASH_SIZE - 1);  // 等价于 hash_key % HASH_SIZE
```

### 6.2 好的哈希函数

```c
// jhash - Jenkins hash，内核通用哈希函数
#include <linux/jhash.h>

unsigned int hash = jhash(key, key_len, initval);

// 示例：哈希 IP 地址
unsigned int hash_ip(__be32 ip)
{
    return jhash_1word(ip, 0);
}

// 哈希字符串
unsigned int hash_string(const char *str)
{
    return jhash(str, strlen(str), 0);
}
```

### 6.3 RCU 保护哈希表

```c
// 查找时使用 RCU
struct my_struct *obj;
unsigned int hash_key = 42;

rcu_read_lock();
hash_for_each_possible_rcu(hashtable, obj, node, hash_key) {
    if (obj->key == hash_key) {
        // 使用 obj
        break;
    }
}
rcu_read_unlock();

// 添加/删除时使用 synchronize_rcu()
hash_del_rcu(&obj->node);
synchronize_rcu();
kfree(obj);
```

---

## 七、调试技巧

```c
// 打印哈希表统计信息
void hash_print_stats(struct hlist_head *htable, unsigned int size)
{
    unsigned int i;
    unsigned int max_chain = 0;
    unsigned int empty = 0;
    unsigned int total = 0;

    for (i = 0; i < size; i++) {
        struct hlist_node *node;
        unsigned int chain_len = 0;

        hlist_for_each(node, &htable[i]) {
            chain_len++;
            total++;
        }

        if (chain_len == 0)
            empty++;
        if (chain_len > max_chain)
            max_chain = chain_len;
    }

    printk("Hash stats: total=%u, empty=%u, max_chain=%u, avg_chain=%u\n",
           total, empty, max_chain, total / (size - empty));
}
```

---

## 八、参考资料

- `include/linux/hashtable.h` - 哈希表 API
- `include/linux/jhash.h` - Jenkins 哈希函数
- `include/linux/list.h` - hlist 相关定义
- [Linux Kernel Data Structures](https://www.kernel.org/doc/html/latest/core-api/kernel-api.html)
- [Kernel Hash Table Implementation](https://www.kernel.org/doc/html/latest/core-api/kernel-api.html#id-functions)
