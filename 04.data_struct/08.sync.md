# Completion / Wait Queue - 同步机制

## 一、概述

Linux 内核提供多种同步机制让一个任务等待另一个任务完成。

| 机制                            | 用途           | 超时支持 | 睡眠   |
|---------------------------------|----------------|----------|--------|
| `completion`                    | 等待一次性事件 | ✓        | 可中断 |
| `wait_queue_head_t`             | 等待事件/资源  | ✓        | 可中断 |
| `wait_queue_head_t` (exclusive) | 独占等待       | ✓        | 可中断 |

---

## 二、Completion (完成量)

### 2.1 数据结构

```c
#include <linux/completion.h>

struct completion {
    unsigned int done;
    wait_queue_head_t wait;
};
```

### 2.2 定义和初始化

```c
/* 静态定义并初始化 */
DECLARE_COMPLETION(my_comp);
DECLARE_COMPLETION_ONSTACK(my_comp);  /* 栈上分配 */

/* 动态定义并初始化 */
struct completion my_comp;
init_completion(&my_comp);

/* 重新初始化 */
reinit_completion(&my_comp);
```

### 2.3 基本操作

```c
/* 等待完成（不可中断）*/
void wait_for_completion(struct completion *c);

/* 可中断等待 */
int wait_for_completion_interruptible(struct completion *c);
/* 返回: -ERESTARTSYS 被中断, 0 正常完成 */

/* 可被杀死信号中断 */
int wait_for_completion_killable(struct completion *c);
/* 返回: -ERESTARTSYS 被杀死, 0 正常完成 */

/* 超时等待 */
unsigned long wait_for_completion_timeout(struct completion *c,
                                          unsigned long timeout);
int wait_for_completion_interruptible_timeout(struct completion *c,
                                               unsigned long timeout);
/* 返回: 0 超时, 正数剩余 jiffies */

/* 完成 */
void complete(struct completion *c);              /* 唤醒一个等待者 */
void complete_all(struct completion *c);          /* 唤醒所有等待者 */

/* 检查是否有等待者 */
bool completion_done(struct completion *c);
```

### 2.4 完整示例

```c
#include <linux/module.h>
#include <linux/completion.h>
#include <linux/kthread.h>

static struct completion dev_comp;
static struct task_struct *task;

/* 工作线程 */
static int worker_thread(void *data)
{
    printk("Worker: start working...\n");

    /* 模拟工作 */
    msleep(3000);

    printk("Worker: work done, signaling...\n");
    complete(&dev_comp);

    return 0;
}

static int __init my_init(void)
{
    init_completion(&dev_comp);

    /* 创建内核线程 */
    task = kthread_run(worker_thread, NULL, "my_worker");
    if (IS_ERR(task))
        return PTR_ERR(task);

    /* 等待工作完成（可超时） */
    unsigned long ret = wait_for_completion_timeout(&dev_comp, msecs_to_jiffies(5000));
    if (ret == 0) {
        printk("Timeout waiting for worker!\n");
        return -ETIMEDOUT;
    }

    printk("Main: worker completed in %lu jiffies\n", 5000 - ret);
    return 0;
}

static void __exit my_exit(void)
{
    /* 如果需要停止线程 */
    if (task)
        kthread_stop(task);
}

module_init(my_init);
module_exit(my_exit);
MODULE_LICENSE("GPL");
```

### 2.5 典型应用

```c
/* DMA 传输完成 */
struct my_driver {
    struct completion xfer_done;
    // ...
};

/* 中断处理 */
static irqreturn_t my_irq_handler(int irq, void *dev_id)
{
    struct my_driver *drv = dev_id;

    /* DMA 传输完成 */
    complete(&drv->xfer_done);

    return IRQ_HANDLED;
}

/* 启动 DMA 并等待 */
int my_start_dma(struct my_driver *drv, dma_addr_t addr, size_t len)
{
    reinit_completion(&drv->xfer_done);

    /* 启动 DMA */
    writel(addr, drv->regs + DMA_ADDR);
    writel(len, drv->regs + DMA_LEN);
    writel(DMA_START, drv->regs + DMA_CTRL);

    /* 等待完成 */
    unsigned long ret = wait_for_completion_timeout(&drv->xfer_done,
                                                     msecs_to_jiffies(1000));
    if (ret == 0)
        return -ETIMEDOUT;

    return 0;
}
```

---

## 三、Wait Queue (等待队列)

### 3.1 数据结构

```c
#include <linux/wait.h>

typedef struct __wait_queue_head wait_queue_head_t;

struct __wait_queue_head {
    spinlock_t      lock;
    struct list_head    task_list;
};

struct wait_queue_entry {
    unsigned int        flags;
    void            *private;
    wait_queue_func_t   func;
    struct list_head    entry;
};
```

### 3.2 定义和初始化

```c
/* 静态定义并初始化 */
DECLARE_WAIT_QUEUE_HEAD(my_wq);

/* 动态定义并初始化 */
wait_queue_head_t my_wq;
init_waitqueue_head(&my_wq);
```

### 3.3 基本操作

```c
/* 睡眠直到条件为真 */
wait_event(wq, condition);
wait_event_interruptible(wq, condition);
wait_event_killable(wq, condition);
wait_event_timeout(wq, condition, timeout);
wait_event_interruptible_timeout(wq, condition, timeout);

/* 唤醒 */
wake_up(wq);              /* 唤醒所有非独占和1个独占等待者 */
wake_up_all(wq);          /* 唤醒所有等待者 */
wake_up_interruptible(wq);  /* 唤醒可中断的等待者 */
wake_up_locked(wq);       /* 已持有锁时使用 */

/* 添加/移除等待队列 */
void add_wait_queue(wait_queue_head_t *q, wait_queue_entry_t *wait);
void remove_wait_queue(wait_queue_head_t *q, wait_queue_entry_t *wait);
```

### 3.4 低级操作

```c
/* 定义等待队列项 */
DECLARE_WAITQUEUE(my_wait, current);

/* 准备睡眠 */
prepare_to_wait(wq, &my_wait, state);
/* state: TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE, TASK_KILLABLE */

/* 检查条件 */
if (!condition) {
    /* 睡眠 */
    schedule();
}

/* 完成睡眠 */
finish_wait(wq, &my_wait);
```

### 3.5 完整示例

```c
#include <linux/module.h>
#include <linux/wait.h>
#include <linux/sched/signal.h>

static DECLARE_WAIT_QUEUE_HEAD(my_wq);
static int flag = 0;
static struct task_struct *reader_thread;

/* 读取线程 */
static int reader_func(void *data)
{
    printk("Reader: waiting for event...\n");

    /* 等待 flag 变为 1（可中断）*/
    wait_event_interruptible(my_wq, flag != 0);

    if (signal_pending(current))
        printk("Reader: interrupted by signal\n");
    else
        printk("Reader: event received!\n");

    return 0;
}

static int __init my_init(void)
{
    /* 创建读取线程 */
    reader_thread = kthread_run(reader_func, NULL, "reader");
    if (IS_ERR(reader_thread))
        return PTR_ERR(reader_thread);

    /* 模拟 2 秒后触发事件 */
    msleep(2000);

    printk("Main: setting flag and waking up readers\n");
    flag = 1;
    wake_up_interruptible(&my_wq);

    return 0;
}

static void __exit my_exit(void)
{
    if (reader_thread)
        kthread_stop(reader_thread);
}

module_init(my_init);
module_exit(my_exit);
MODULE_LICENSE("GPL");
```

### 3.6 独占等待

```c
/* 定义独占等待 */
DEFINE_WAIT(my_wait);

/* 独占等待 - 唤醒时只唤醒一个 */
static int exclusive_wait(void)
{
    DEFINE_WAIT(wait);

    while (!condition) {
        prepare_to_wait_exclusive(&wq, &wait, TASK_INTERRUPTIBLE);

        if (!condition)
            schedule();

        finish_wait(&wq, &wait);

        if (signal_pending(current))
            return -ERESTARTSYS;
    }

    return 0;
}

/* 唤醒时只唤醒一个独占等待者 */
wake_up(&my_wq);
```

### 3.7 典型应用 - poll 实现

```c
/* 驱动 poll 实现 */
static unsigned int my_poll(struct file *file, poll_table *wait)
{
    struct my_dev *dev = file->private_data;
    unsigned int mask = 0;

    poll_wait(file, &dev->read_wq, wait);

    if (data_available(dev))
        mask |= POLLIN | POLLRDNORM;

    if (space_available(dev))
        mask |= POLLOUT | POLLWRNORM;

    return mask;
}

/* 数据到达时唤醒 */
static void data_arrived(struct my_dev *dev)
{
    /* ... 处理数据 ... */

    /* 唤醒读取者 */
    wake_up_interruptible(&dev->read_wq);
}
```

---

## 四、Completion vs Wait Queue

| 特性         | Completion            | Wait Queue          |
|--------------|-----------------------|---------------------|
| **使用场景** | 一次性事件            | 可重复事件          |
| **状态**     | done 计数             | 条件判断            |
| **完成**     | complete/complete_all | wake_up/wake_up_all |
| **唤醒**     | 所有或一个等待者      | 所有或独占等待者    |
| **重复使用** | 需要重新初始化        | 自动                |
| **典型用途** | DMA 完成、模块加载    | 数据到达、资源可用  |

---

## 五、高级用法

### 5.1 多个完成量

```c
/* 分阶段完成 */
struct my_device {
    struct completion init_done;
    struct completion tx_done;
    struct completion rx_done;
};

/* 初始化 */
init_completion(&dev->init_done);
init_completion(&dev->tx_done);
init_completion(&dev->rx_done);

/* 等待初始化 */
wait_for_completion(&dev->init_done);

/* 同时等待多个（不推荐，容易死锁）*/
```

### 5.2 超时处理

```c
/* DMA 超时重试 */
int my_dma_transfer(struct device *dev, dma_addr_t addr, size_t len)
{
    int retry = 3;

    while (retry--) {
        reinit_completion(&dev->dma_done);

        start_dma(dev, addr, len);

        if (wait_for_completion_timeout(&dev->dma_done,
                                        msecs_to_jiffies(1000)))
            return 0;  /* 成功 */

        /* 超时，重试 */
        cancel_dma(dev);
        dev_err(dev->dev, "DMA timeout, retrying...\n");
    }

    return -ETIMEDOUT;
}
```

### 5.3 使用 wait_event 的最佳实践

```c
/* 检查条件函数 */
static bool data_ready(struct my_dev *dev)
{
    return !list_empty(&dev->rx_list);
}

/* 读取函数 */
static ssize_t my_read(struct file *file, char __user *buf,
                       size_t count, loff_t *ppos)
{
    struct my_dev *dev = file->private_data;

    /* 等待数据就绪 */
    if (wait_event_interruptible(dev->read_wq, data_ready(dev)))
        return -ERESTARTSYS;

    /* 读取数据 */
    return process_data(dev, buf, count);
}
```

---

## 六、调试技巧

```c
/* 检查等待队列状态 */
void dump_wait_queue(wait_queue_head_t *wq, const char *name)
{
    printk("%s:\n", name);
    printk("  lock: %s\n", spin_is_locked(&wq->lock) ? "locked" : "unlocked");
    printk("  task_list: %s\n",
           list_empty(&wq->task_list) ? "empty" : "has waiters");
}

/* 完成量状态 */
void dump_completion(struct completion *c, const char *name)
{
    printk("%s: done=%u\n", name, c->done);
}
```

---

## 七、注意事项

1. **避免死锁**
   ```c
   /* 错误：持有锁时睡眠 */
   spinlock_t lock;
   spin_lock(&lock);
   wait_event(wq, condition);  /* 死锁！ */
   spin_unlock(&lock);

   /* 正确 */
   spin_unlock(&lock);
   wait_event(wq, condition);
   spin_lock(&lock);
   ```

2. **检查返回值**
   ```c
   /* 可中断等待必须检查 */
   if (wait_event_interruptible(wq, condition))
       return -ERESTARTSYS;
   ```

3. **complete_all 后重新初始化**
   ```c
   complete_all(&comp);
   /* 下次使用前需要重新初始化 */
   reinit_completion(&comp);
   ```

4. **不要在原子上下文睡眠**
   ```c
   /* 错误：在中断处理中睡眠 */
   irqreturn_t my_irq(int irq, void *dev)
   {
       wait_event(wq, condition);  /* 错误！ */
       return IRQ_HANDLED;
   }
   ```

---

## 八、参考资料

- `include/linux/completion.h` - Completion API
- `include/linux/wait.h` - Wait Queue API
- `Documentation/scheduler/completion.txt` - Completion 文档
- [Sleeping and Waking](https://www.kernel.org/doc/html/latest/core-api/wait-api.html)
