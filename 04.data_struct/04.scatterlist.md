# Scatterlist (分散表)

## 一、什么是 Scatterlist

Scatterlist 是 Linux 内核用于描述**不连续物理内存**的数据结构，主要用于 DMA
（直接内存访问）操作。它允许 DMA 控制器对分散在物理内存中的多个内存块进行一次性
的"分散-收集"（Scatter-Gather）传输。

### 为什么需要 Scatterlist？

```
传统 DMA 要求内存连续：
┌────────────────────────────────────┐
│   大块连续物理内存 (难分配)        │
└────────────────────────────────────┘

使用 Scatterlist 可以处理分散内存：
┌─────┐        ┌─────┐        ┌─────┐
│ Pg1 │        │ Pg3 │        │ Pg7 │  ← 物理上不连续
│ 4KB │        │ 4KB │        │ 4KB │
└─────┘        └─────┘        └─────┘
  0x1000        0x5000        0x9000
    │             │             │
    └─────────────┴─────────────┘
                  │
         Scatterlist 串联它们
                  │
          DMA 控制器按顺序访问
```

### 与其他"散列表"的区别

| 名称              | 英文         | 用途               |
|-------------------|--------------|--------------------|
| **哈希表/散列表** | Hash Table   | 快速查找 key-value |
| **分散表/散列表** | Scatterlist  | 管理不连续物理内存 |

---

## 二、数据结构

### 2.1 struct scatterlist

```c
#include <linux/scatterlist.h>

struct scatterlist {
    unsigned long    page_link;    /* 页面链接或标志 */
    unsigned int    offset;        /* 页内偏移 */
    unsigned int    length;        /* 此段长度 */
    dma_addr_t      dma_address;   /* DMA 地址（映射后） */
};

/* sg_table - 现代 API 推荐使用 */
struct sg_table {
    struct scatterlist *sgl;       /* scatterlist 数组 */
    unsigned int        nents;     /* DMA 映射后的段数 */
    unsigned int        orig_nents;/* 原始段数 */
};
```

### 2.2 scatterlist 标志

```c
#define SG_END        0UL           /* 列表结束 */
#define SG_CHAIN      0x01UL        /* 链接到下一个 scatterlist */
```

---

## 三、基本操作

### 3.1 初始化 scatterlist

```c
#include <linux/scatterlist.h>

/* 方式1：静态分配 */
#define SG_MAX_SEGMENTS   16
struct scatterlist sg_list[SG_MAX_SEGMENTS];

/* 初始化 scatterlist 数组 */
sg_init_table(sg_list, SG_MAX_SEGMENTS);

/* 方式2：动态分配 */
struct scatterlist *sg_list;
int nents = 16;

sg_list = kmalloc_array(nents, sizeof(*sg_list), GFP_KERNEL);
if (!sg_list)
    return -ENOMEM;

sg_init_table(sg_list, nents);
```

### 3.2 构建 scatterlist

```c
/* 从页面构建 */
struct page *pages[PAGE_COUNT];
int i;

for (i = 0; i < PAGE_COUNT; i++) {
    pages[i] = alloc_page(GFP_KERNEL);
    sg_set_page(&sg_list[i], pages[i], PAGE_SIZE, 0);
}

/* 从虚拟地址构建（必须是物理连续的） */
void *virt_addr = kmalloc(4096, GFP_KERNEL);
sg_set_buf(&sg_list[0], virt_addr, 4096);

/* 设置原始地址和长度（不常用） */
sg_set_page(&sg_list[i], page, length, offset);
```

### 3.3 DMA 映射

```c
#include <linux/dma-mapping.h>

struct device *dev = &my_dev->dev;
int nents_out;

/* 映射 scatterlist 用于 DMA */
nents_out = dma_map_sg(dev, sg_list, nents, DMA_TO_DEVICE);
if (nents_out == 0) {
    printk("DMA mapping failed\n");
    return -EIO;
}

/* 注意：nents_out 可能小于 nents（IOMMU 合并了相邻段） */
```

### 3.4 遍历 scatterlist

```c
/* 传统遍历方式 */
struct scatterlist *sg;
int i;

for_each_sg(sg_list, sg, nents_out, i) {
    dma_addr_t dma_addr = sg_dma_address(sg);
    unsigned int len = sg_dma_len(sg);
    phys_addr_t phys_addr = sg_phys(sg);

    printk("sg[%d]: dma=0x%pad, phys=0x%pa, len=0x%x\n",
           i, &dma_addr, &phys_addr, len);
}

/* 使用 sg_table 的现代遍历方式 */
struct sg_table sgt;

for_each_sgtable_sg(&sgt, sg, i) {
    dma_addr_t dma_addr = sg_dma_address(sg);
    unsigned int len = sg_dma_len(sg);
    phys_addr_t phys_addr = sg_phys(sg);

    printk("sg[%d]: dma=0x%pad, phys=0x%pa, len=0x%x\n",
           i, &dma_addr, &phys_addr, len);
}
```

### 3.5 DMA 取消映射

```c
/* 取消映射 */
dma_unmap_sg(dev, sg_list, nents, DMA_TO_DEVICE);

/* 使用 sg_table */
dma_unmap_sgtable(dev, &sgt, DMA_TO_DEVICE, 0);
```

### 3.6 释放 scatterlist

```c
/* 释放 sg_table */
sg_free_table(&sgt);
kfree(sgt.sgl);

/* 释放静态分配的 */
kfree(sg_list);
```

---

## 四、使用 sg_table（现代方式）

### 4.1 分配和初始化

```c
#include <linux/scatterlist.h>

struct sg_table sgt;
int ret;

/* 分配 sg_table */
ret = sg_alloc_table(&sgt, nr_segments, GFP_KERNEL);
if (ret)
    return ret;

/* 填充 scatterlist */
for (i = 0; i < nr_segments; i++) {
    sg_set_page(&sgt.sgl[i], pages[i], PAGE_SIZE, 0);
}

/* DMA 映射 */
ret = dma_map_sgtable(dev, &sgt, DMA_TO_DEVICE, 0);
if (ret) {
    sg_free_table(&sgt);
    return ret;
}
```

### 4.2 使用 dma_alloc_noncontiguous（更现代）

```c
/* v5.13+ 新 API */
struct sg_table *sgt;
size_t size = SZ_1M;  /* 1MB */

sgt = dma_alloc_noncontiguous(dev, size, DMA_TO_DEVICE, GFP_KERNEL, 0);
if (!sgt)
    return -ENOMEM;

/* 遍历 */
struct scatterlist *sg;
int i;

for_each_sgtable_sg(sgt, sg, i) {
    printk("seg[%d]: dma=0x%pad, len=0x%x\n",
           i, &sg_dma_address(sg), sg_dma_len(sg));
}

/* 释放 */
dma_free_noncontiguous(dev, size, sgt, DMA_TO_DEVICE);
```

---

## 五、调试打印示例

```c
/* 打印 scatterlist 信息（调试用）*/
static void dump_scatterlist(struct sg_table *sgt, int fd)
{
    struct scatterlist *sg;
    int i;

    if (!sgt || !sgt->sgl)
        return;

    pr_info("=== Scatterlist Dump (fd=%d) ===\n", fd);
    pr_info("orig_nents=%u, nents=%u\n", sgt->orig_nents, sgt->nents);

    for_each_sgtable_sg(sgt, sg, i) {
        dma_addr_t dma_addr = sg_dma_address(sg);
        phys_addr_t phys_addr = sg_phys(sg);
        unsigned int len = sg_dma_len(sg);

        pr_info("  sg[%d]: dma_addr=0x%pad, phys_addr=0x%pa (below 4G: %s), len=0x%x\n",
               i, &dma_addr, &phys_addr,
               phys_addr < SZ_4G ? "yes" : "no",
               len);
    }
    pr_info("================================\n");
}
```

---

## 六、内核应用示例

### 6.1 块设备驱动

```c
/* block/blk-mq.c */
struct request {
    struct scatterlist *special_vec;  /* 特殊向量 */
    int               nr_phys_segments; /* 物理段数 */
    // ...
};

/* 块设备提交 I/O */
static blk_status_t blk_queue_bio(struct request_queue *q, struct bio *bio)
{
    struct req_iterator iter;
    struct bio_vec bvec;

    /* 遍历 bio 中的每个段 */
    rq_for_each_segment(bvec, req, iter) {
        /* 构建 scatterlist */
        sg_set_page(&sglist[i], bvec.bv_page,
                    bvec.bv_len, bvec.bv_offset);
    }

    /* DMA 映射 */
    nents = dma_map_sg(dev, sglist, nents, rq_dma_dir(req));

    /* 提交到硬件 */
    hw_submit_sg(sglist, nents);

    return BLK_STS_OK;
}
```

### 6.2 网络驱动

```c
/* 网络 SKB scatter-gather */
struct sk_buff {
    skb_frag_t frags[MAX_SKB_FRAGS];
    unsigned int nr_frags;
    // ...
};

/* 遍历网络数据包的分片 */
int i;
skb_frag_t *frag;

for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
    frag = &skb_shinfo(skb)->frags[i];

    /* 构建 scatterlist */
    sg_set_page(&sg_list[i], skb_frag_page(frag),
                skb_frag_size(frag), skb_frag_off(frag));
}

/* DMA 映射并传输 */
dma_map_sg(dev, sg_list, nents, DMA_TO_DEVICE);
```

---

## 七、API 对比

| 功能     | 旧 API            | 新 API (sg_table)       |
|----------|-------------------|-------------------------|
| 初始化   | `sg_init_table()` | `sg_alloc_table()`      |
| 遍历     | `for_each_sg()`   | `for_each_sgtable_sg()` |
| DMA 映射 | `dma_map_sg()`    | `dma_map_sgtable()`     |
| DMA 取消 | `dma_unmap_sg()`  | `dma_unmap_sgtable()`   |
| 释放     | `kfree()`         | `sg_free_table()`       |

---

## 八、注意事项

1. **物理连续 vs 虚拟连续**
   - `sg_set_buf()` 要求虚拟地址对应的物理内存是连续的
   - 如果使用 `vmalloc()`，需要逐页构建

2. **DMA 方向**
   - `DMA_TO_DEVICE` - 内存到设备
   - `DMA_FROM_DEVICE` - 设备到内存
   - `DMA_BIDIRECTIONAL` - 双向

3. **nents 变化**
   - `dma_map_sg()` 返回的段数可能小于输入
   - IOMMU 可能合并相邻的段

4. **地址类型**
   - `sg_phys()` - 物理地址
   - `sg_dma_address()` - DMA/总线地址（可能经过 IOMMU）

---

## 九、参考资料

- `include/linux/scatterlist.h` - scatterlist API
- `Documentation/DMA-API.txt` - DMA API 文档
- [DMA mapping 详解](../6.dma/1.dma.md) - 项目内的 DMA 文档
- [Kernel Scatterlist API](https://www.kernel.org/doc/html/latest/core-api/dma-api.html)
