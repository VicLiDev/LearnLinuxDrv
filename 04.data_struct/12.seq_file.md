# Seq_file (序列文件接口)

## 一、概述

Seq_file 是 Linux 内核提供的**虚拟文件系统接口**，用于在 `/proc`、`/sys`、`debugfs`
等虚拟文件系统中**格式化输出大量数据**。

### 为什么需要 seq_file？

```
传统方式（直接 read）：
  - 需要一次性生成所有数据
  - 大数据量时内存占用高
  - 需要处理 offset/pos

Seq_file 方式：
  - 按需生成数据
  - 自动处理分页
  - 内存占用低
  - API 简单
```

---

## 二、Seq_file 基本结构

### 2.1 核心数据结构

```c
#include <linux/seq_file.h>

/* Seq_file 操作 */
struct seq_operations {
    void * (*start) (struct seq_file *m, loff_t *pos);
    void (*stop) (struct seq_file *m, void *v);
    void * (*next) (struct seq_file *m, void *v, loff_t *pos);
    int (*show) (struct seq_file *m, void *v);
};

/* 文件操作 */
struct file_operations {
    // ...
    const struct seq_operations *seq_ops;
};
```

### 2.2 seq_file 生命周期

```
用户读取文件:
    open()
      │
      ▼
    seq_open()
      │
      ▼
    start() ──> show() ──> next() ──> show() ──> ... ──> stop()
      ▲                                                │
      └────────────────────────────────────────────────┘
                           │
                           ▼
                        release()
```

---

## 三、基本 Seq_file 实现

### 3.1 简单示例

```c
#include <linux/module.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>
#include <linux/uaccess.h>

/* 私有数据 */
static struct list_head my_list;
static DEFINE_SPINLOCK(my_lock);

struct my_entry {
    int value;
    struct list_head list;
};

/* start: 开始遍历 */
static void *my_seq_start(struct seq_file *m, loff_t *pos)
{
    spin_lock(&my_lock);
    return seq_list_start(&my_list, *pos);
}

/* stop: 结束遍历 */
static void my_seq_stop(struct seq_file *m, void *v)
{
    spin_unlock(&my_lock);
}

/* next: 下一个条目 */
static void *my_seq_next(struct seq_file *m, void *v, loff_t *pos)
{
    return seq_list_next(v, &my_list, pos);
}

/* show: 打印一个条目 */
static int my_seq_show(struct seq_file *m, void *v)
{
    struct my_entry *entry = list_entry(v, struct my_entry, list);
    seq_printf(m, "value=%d\n", entry->value);
    return 0;
}

/* Seq 操作 */
static const struct seq_operations my_seq_ops = {
    .start = my_seq_start,
    .next  = my_seq_next,
    .stop  = my_seq_stop,
    .show  = my_seq_show,
};

/* 打开文件 */
static int my_proc_open(struct inode *inode, struct file *file)
{
    return seq_open(file, &my_seq_ops);
}

/* 文件操作 */
static const struct proc_ops my_proc_ops = {
    .proc_open    = my_proc_open,
    .proc_read    = seq_read,
    .proc_lseek   = seq_lseek,
    .proc_release = seq_release,
};

static int __init my_init(void)
{
    INIT_LIST_HEAD(&my_list);

    /* 创建 /proc 文件 */
    proc_create("my_data", 0, NULL, &my_proc_ops);

    /* 添加一些测试数据 */
    int i;
    for (i = 0; i < 10; i++) {
        struct my_entry *entry = kmalloc(sizeof(*entry), GFP_KERNEL);
        entry->value = i * 100;
        list_add(&entry->list, &my_list);
    }

    return 0;
}

static void __exit my_exit(void)
{
    struct my_entry *entry, *tmp;

    list_for_each_entry_safe(entry, tmp, &my_list, list) {
        list_del(&entry->list);
        kfree(entry);
    }

    remove_proc_entry("my_data", NULL);
}

module_init(my_init);
module_exit(my_exit);
MODULE_LICENSE("GPL");
```

---

## 四、单值输出

### 4.1 single_open

```c
#include <linux/seq_file.h>
#include <linux/proc_fs.h>

/* show 函数：一次性输出所有数据 */
static int my_single_show(struct seq_file *m, void *v)
{
    seq_printf(m, "Hello from seq_file!\n");
    seq_printf(m, "Kernel version: %s\n", UTS_RELEASE);
    return 0;
}

/* 打开文件 */
static int my_single_open(struct inode *inode, struct file *file)
{
    return single_open(file, my_single_show, NULL);
}

/* 文件操作 */
static const struct proc_ops my_single_proc_ops = {
    .proc_open    = my_single_open,
    .proc_read    = seq_read,
    .proc_lseek   = seq_lseek,
    .proc_release = single_release,
};

static int __init my_init(void)
{
    proc_create("my_info", 0, NULL, &my_single_proc_ops);
    return 0;
}
```

---

## 五、Debugfs 接口

### 5.1 debugfs 创建 seq_file

```c
#include <linux/debugfs.h>
#include <linux/seq_file.h>

static struct dentry *debug_dir;

/* Seq 操作 */
static int my_debug_show(struct seq_file *m, void *v)
{
    struct my_data *data = m->private;

    seq_printf(m, "Counter: %d\n", data->counter);
    seq_printf(m, "Status: %s\n", data->status ? "OK" : "ERROR");

    return 0;
}

static int my_debug_open(struct inode *inode, struct file *file)
{
    return single_open(file, my_debug_show, inode->i_private);
}

static const struct file_operations my_debug_fops = {
    .owner   = THIS_MODULE,
    .open    = my_debug_open,
    .read    = seq_read,
    .llseek  = seq_lseek,
    .release = single_release,
};

static int __init my_init(void)
{
    /* 创建 debugfs 目录 */
    debug_dir = debugfs_create_dir("my_driver", NULL);

    /* 创建 seq_file */
    debugfs_create_file("status", 0444, debug_dir,
                        &my_data, &my_debug_fops);

    /* 创建其他文件 */
    debugfs_create_u32("counter", 0644, debug_dir, &my_data.counter);
    debugfs_create_bool("enabled", 0644, debug_dir, &my_data.enabled);

    return 0;
}

static void __exit my_exit(void)
{
    debugfs_remove_recursive(debug_dir);
}
```

---

## 六、高级用法

### 6.1 私有数据传递

```c
/* 每个打开文件的私有数据 */
struct my_seq_private {
    struct my_device *dev;
    int filter;
};

static int my_seq_open(struct inode *inode, struct file *file)
{
    struct my_seq_private *priv;
    int ret;

    /* 分配私有数据 */
    priv = __seq_open_private(file, &my_seq_ops, sizeof(*priv));
    if (IS_ERR(priv))
        return PTR_ERR(priv);

    /* 初始化私有数据 */
    priv->dev = PDE_DATA(inode);
    priv->filter = 0;

    return 0;
}

static int my_seq_show(struct seq_file *m, void *v)
{
    struct my_seq_private *priv = m->private;

    if (priv->filter && !match_filter(v, priv->filter))
        return 0;

    /* 打印数据 */
    seq_printf(m, "data=%p\n", v);

    return 0;
}
```

### 6.2 写入支持

```c
/* 写入回调 */
static ssize_t my_seq_write(struct file *file, const char __user *buf,
                            size_t count, loff_t *ppos)
{
    struct seq_file *m = file->private_data;
    struct my_data *data = m->private;
    char kbuf[32];
    int val;

    if (count >= sizeof(kbuf))
        return -EINVAL;

    if (copy_from_user(kbuf, buf, count))
        return -EFAULT;

    kbuf[count] = '\0';

    if (kstrtoint(kbuf, 10, &val))
        return -EINVAL;

    data->value = val;

    return count;
}

static const struct proc_ops my_proc_ops = {
    .proc_open    = my_proc_open,
    .proc_read    = seq_read,
    .proc_write   = my_seq_write,
    .proc_lseek   = seq_lseek,
    .proc_release = seq_release,
};
```

### 6.3 大数据处理

```c
/* 处理大量数据，避免一次性加载 */
static void *my_seq_start(struct seq_file *m, loff_t *pos)
{
    loff_t index = *pos;

    if (index >= MAX_ENTRIES)
        return NULL;

    /* 返回第 index 个条目 */
    return get_entry_by_index(index);
}

static void *my_seq_next(struct seq_file *m, void *v, loff_t *pos)
{
    (*pos)++;

    if (*pos >= MAX_ENTRIES)
        return NULL;

    return get_entry_by_index(*pos);
}
```

---

## 七、Seq_file 辅助函数

### 7.1 输出函数

```c
/* 格式化输出 */
int seq_printf(struct seq_file *m, const char *fmt, ...);

/* 输出字符串 */
int seq_puts(struct seq_file *m, const char *s);

/* 输出单个字符 */
int seq_putc(struct seq_file *m, char c);

/* 转义输出（处理特殊字符）*/
int seq_escape(struct seq_file *m, const char *s, const char *esc);

/* 输出十六进制 */
int seq_write(struct seq_file *m, const void *data, size_t len);

/* 输出内存 */
int seq_hex_dump(struct seq_file *m, const char *prefix_str,
                 int prefix_type, int rowsize, int groupsize,
                 const void *buf, size_t len, bool ascii);
```

### 7.2 链表辅助函数

```c
/* 链表遍历 */
void *seq_list_start(struct list_head *head, loff_t pos);
void *seq_list_next(void *v, struct list_head *head, loff_t *ppos);
void *seq_list_start_head(struct list_head *head, loff_t pos);

/* hlist 遍历 */
void *seq_hlist_start(struct hlist_head *head, loff_t pos);
void *seq_hlist_next(void *v, struct hlist_head *head,
                      loff_t *ppos);
```

### 7.3 使用示例

```c
/* 使用 list 辅助函数 */
static void *my_seq_start(struct seq_file *m, loff_t *pos)
{
    return seq_list_start(&my_list, *pos);
}

static void *my_seq_next(struct seq_file *m, void *v, loff_t *pos)
{
    return seq_list_next(v, &my_list, pos);
}

static int my_seq_show(struct seq_file *m, void *v)
{
    struct my_entry *entry = list_entry(v, struct my_entry, list);

    /* 输出各种格式 */
    seq_printf(m, "entry: %p\n", entry);
    seq_puts(m, "  fields:\n");
    seq_printf(m, "    value=%d\n", entry->value);

    /* 十六进制转储 */
    if (entry->data)
        seq_hex_dump(m, "    data: ", DUMP_PREFIX_OFFSET,
                     16, 1, entry->data, entry->len, true);

    return 0;
}
```

---

## 八、典型应用

### 8.1 进程信息 (/proc)

```c
/* 内核中 /proc/[pid]/status 的实现 */
static int proc_pid_status(struct seq_file *m, struct pid_namespace *ns,
                            struct pid *pid, struct task_struct *task)
{
    seq_printf(m, "Name:\t%s\n", task->comm);
    seq_printf(m, "State:\t%c\n", get_task_state(task));
    seq_printf(m, "Pid:\t%d\n", task->pid);
    /* ... 更多信息 ... */
    return 0;
}
```

### 8.2 中断统计 (/proc/interrupts)

```c
static int show_interrupts(struct seq_file *p, void *v)
{
    int i = *(loff_t *) v;

    seq_printf(p, "%*d: ", irq_width, i);
    for_each_online_cpu(j)
        seq_printf(p, "%10u ", kstat_irqs_cpu(i, j));

    seq_printf(p, "  %s\n", irq_desc[i].name);

    return 0;
}
```

### 8.3 驱动调试接口

```c
/* 驱动状态调试文件 */
static int driver_status_show(struct seq_file *m, void *v)
{
    struct my_driver *drv = m->private;

    seq_printf(m, "Driver: %s\n", drv->name);
    seq_printf(m, "State: %s\n", drv->state ? "RUNNING" : "STOPPED");
    seq_printf(m, "TX packets: %llu\n", drv->tx_packets);
    seq_printf(m, "RX packets: %llu\n", drv->rx_packets);

    /* 错误统计 */
    seq_printf(m, "\nErrors:\n");
    seq_printf(m, "  TX errors: %u\n", drv->tx_errors);
    seq_printf(m, "  RX errors: %u\n", drv->rx_errors);

    return 0;
}
```

---

## 九、调试技巧

```c
/* 检查 seq_file 状态 */
void debug_seq_file(struct seq_file *m)
{
    printk("Seq_file: buf=%p, size=%zu, from=%zu, count=%zu\n",
           m->buf, m->size, m->from, m->count);
    printk("  index=%llu, pos=%llu\n", m->index, m->pos);
}

/* 打印当前位置 */
void debug_position(struct seq_file *m, void *v)
{
    printk("Current position: v=%p, pos=%llu\n", v, m->pos);
}
```

---

## 十、注意事项

1. **加锁范围**
   ```c
   /* 正确：在 start 中加锁，stop 中解锁 */
   static void *my_start(struct seq_file *m, loff_t *pos)
   {
       spin_lock(&lock);
       return seq_list_start(&head, *pos);
   }

   static void my_stop(struct seq_file *m, void *v)
   {
       spin_unlock(&lock);
   }
   ```

2. **show 返回值**
   ```c
   /* show 返回 0 继续下一个，非 0 停止遍历 */
   static int my_show(struct seq_file *m, void *v)
   {
       if (should_skip(v))
           return 0;  /* 跳过当前，继续下一个 */

       return 0;  /* 正常返回 0 */
   }
   ```

3. **内存管理**
   ```c
   /* 使用 __seq_open_private 自动管理私有数据 */
   static int my_open(struct inode *inode, struct file *file)
   {
       struct my_private *priv;

       priv = __seq_open_private(file, &my_seq_ops, sizeof(*priv));
       if (IS_ERR(priv))
           return PTR_ERR(priv);

       /* 初始化 priv */
       priv->data = inode->i_private;

       return 0;
   }

   /* 关闭时自动释放 */
   ```

4. **避免睡眠**
   ```c
   /* show 函数中不能睡眠 */
   static int my_show(struct seq_file *m, void *v)
   {
       msleep(100);  /* 错误！不能睡眠 */

       /* 正确：使用 GFP_ATOMIC */
       void *buf = kmalloc(size, GFP_ATOMIC);
   }
   ```

---

## 十一、参考资料

- `include/linux/seq_file.h` - Seq_file API
- `include/linux/proc_fs.h` - Proc 文件系统
- `include/linux/debugfs.h` - Debugfs API
- [Seq_file documentation](https://www.kernel.org/doc/html/latest/filesystems/seq_file.html)
