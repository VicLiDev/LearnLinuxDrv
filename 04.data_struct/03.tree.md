# 树结构 (Tree Structures)

## 概述

Linux 内核中使用了多种树形数据结构，主要用于：
- **红黑树** - 需要有序查找和范围查询
- **Radix Tree** - 快速指针查找，按位索引
- **XArray** - Radix Tree 的现代替代品

---

## 一、红黑树 (Red-Black Tree)

### 1.1 什么是红黑树

红黑树是一种**自平衡二叉搜索树**，具有以下性质：
1. 每个节点要么红色要么黑色
2. 根节点是黑色
3. 所有叶子节点（NIL）是黑色
4. 红色节点的两个子节点都是黑色
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

### 1.2 时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| 查找 | O(log n) | 二分查找 |
| 插入 | O(log n) | 插入后需要重新平衡 |
| 删除 | O(log n) | 删除后需要重新平衡 |
| 范围查询 | O(log n + k) | k 是结果数量 |

### 1.3 数据结构

```c
#include <linux/rbtree.h>

struct rb_node {
    unsigned long  __rb_parent_color;
    struct rb_node *rb_right;
    struct rb_node *rb_left;
};

// 红黑树根
struct rb_root {
    struct rb_node *rb_node;
};

// 红黑树根（已初始化）
#define RB_ROOT (struct rb_root) { NULL, }
```

### 1.4 定义包含红黑树节点的数据结构

```c
struct my_struct {
    int key;
    char data[32];
    struct rb_node node;  // 红黑树节点
};
```

### 1.5 基本操作

#### 初始化

```c
// 静态初始化
struct rb_root my_tree = RB_ROOT;

// 动态初始化
struct rb_root my_tree;
my_tree.rb_node = NULL;
```

#### 插入节点

```c
#include <linux/rbtree.h>

struct rb_node **new = &(my_tree.rb_node);
struct rb_node *parent = NULL;
struct my_struct *data = kmalloc(sizeof(*data), GFP_KERNEL);

data->key = 42;
strscpy(data->data, "hello", sizeof(data->data));

/* 找到插入位置 */
while (*new) {
    struct my_struct *this = container_of(*new, struct my_struct, node);

    parent = *new;
    if (data->key < this->key)
        new = &((*new)->rb_left);
    else if (data->key > this->key)
        new = &((*new)->rb_right);
    else
        return -EEXIST;  // key 已存在
}

/* 添加新节点 */
rb_link_node(&data->node, parent, new);
rb_insert_color(&data->node, &my_tree);
```

#### 查找节点

```c
struct my_struct *my_search(struct rb_root *root, int key)
{
    struct rb_node *node = root->rb_node;

    while (node) {
        struct my_struct *data = container_of(node, struct my_struct, node);

        if (key < data->key)
            node = node->rb_left;
        else if (key > data->key)
            node = node->rb_right;
        else
            return data;  // 找到
    }
    return NULL;  // 未找到
}
```

#### 删除节点

```c
struct my_struct *data = my_search(&my_tree, 42);
if (data) {
    rb_erase(&data->node, &my_tree);
    kfree(data);
}
```

#### 遍历红黑树

```c
/* 中序遍历（从小到大） */
void my_inorder(struct rb_node *node)
{
    if (!node)
        return;

    my_inorder(node->rb_left);

    struct my_struct *data = container_of(node, struct my_struct, node);
    printk("key=%d, data=%s\n", data->key, data->data);

    my_inorder(node->rb_right);
}

/* 调用 */
my_inorder(my_tree.rb_node);

/* 后序遍历（用于删除所有节点） */
struct rb_node *node;
for (node = rb_first(&my_tree); node; node = rb_next(node)) {
    struct my_struct *data = container_of(node, struct my_struct, node);
    printk("key=%d\n", data->key);
}
```

### 1.6 内核应用示例

#### 虚拟内存区域 (VMA)

```c
// mm/mmap.c

/* 每个进程的 mm_struct 包含一棵红黑树存储所有 VMA */
struct mm_struct {
    struct vm_area_struct *mmap;        /* VMA 红黑树 */
    struct rb_root mm_rb;              /* 红黑树根 */
    struct rw_semaphore mmap_sem;
    // ...
};

struct vm_area_struct {
    unsigned long vm_start;            /* 起始地址 */
    unsigned long vm_end;              /* 结束地址 */
    struct rb_node vm_rb;              /* 红黑树节点 */
    // ...
};

/* 查找指定地址的 VMA */
struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)
{
    struct rb_node *rb_node;
    struct vm_area_struct *vma;

    rb_node = mm->mm_rb.rb_node;
    while (rb_node) {
        struct vm_area_struct *vma_tmp;

        vma_tmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);

        if (vma_tmp->vm_end > addr) {
            vma = vma_tmp;
            if (vma_tmp->vm_start <= addr)
                return vma;
            rb_node = rb_node->rb_left;
        } else
            rb_node = rb_node->rb_right;
    }
    return vma;
}
```

#### CFS 进程调度器

```c
// kernel/sched/fair.c

/* 调度实体包含红黑树节点 */
struct sched_entity {
    struct load_weight    load;
    struct rb_node        run_node;      /* 红黑树节点 */
    u64                   exec_start;
    u64                   sum_exec_runtime;
    // ...
};

/* 调度队列包含红黑树存储所有可运行进程 */
struct cfs_rq {
    struct load_weight load;
    u64 nr_running;
    struct rb_root tasks_timeline;      /* 红黑树根 */
    struct rb_node *rb_leftmost;        /* 最左节点（vruntime 最小） */
    // ...
};
```

### 1.7 增强版：Augmented Red-Black Tree

内核提供了增强版红黑树，可以在每个节点存储额外的聚合信息：

```c
/* 定义增强函数 */
static inline unsigned long
compute_subtree(struct rb_node *node)
{
    struct my_struct *data = rb_entry(node, struct my_struct, node);
    unsigned long max = data->value;

    if (node->rb_left)
        max = max(max, rb_entry(node->rb_left, struct my_struct, node)->subtree_max);
    if (node->rb_right)
        max = max(max, rb_entry(node->rb_right, struct my_struct, node)->subtree_max);

    return max;
}

/* 声明增强红黑树 */
RB_DECLARE_CALLBACKS_MAX(static, my_augment, struct my_struct, node,
                         subtree_max, compute_subtree)

/* 插入时更新增强信息 */
rb_insert_augmented(&data->node, &my_tree, &my_augment);
```

---

## 二、Radix Tree (基数树)

### 2.1 什么是 Radix Tree

Radix Tree 是一种**基于位的前缀树**，可以高效地根据整数索引查找指针。它是 Linux
页缓存的核心数据结构。

### 2.2 结构示意图

```
Radix Tree (每个节点最多 64 个子节点，使用 6 位索引)

                        ROOT
                     /   |   \  \
                    /    |    \  \
                   /     |     \  \
                  /      |      \  \
          0xxxxx   10xxxx  11xxxx  ...
           |         |
      INDEX=0    INDEX=1
```

### 2.3 数据结构

```c
#include <linux/xarray.h>  // 现代 API 推荐
#include <linux/radix-tree.h>  // 旧 API（已废弃）

/* XArray 是 Radix Tree 的现代替代 */
struct xarray {
    spinlock_t xa_lock;
    gfp_t xa_flags;
    struct xa_node *xa_head;  /* 根节点 */
};

/* 初始化 */
DEFINE_XARRAY(name);
void xa_init(struct xarray *xa);
```

### 2.4 XArray 基本操作

#### 插入条目

```c
struct xarray xa;
xa_init(&xa);

/* 插入条目 */
void *entry = kmalloc(sizeof(*entry), GFP_KERNEL);
int index = 42;

int ret = xa_insert(&xa, index, entry, GFP_KERNEL);
if (ret)
    printk("Insert failed: %d\n", ret);

/* 存储特定值（如 XA_ZERO_LOCK_ENTRY 表示互斥锁） */
xa_store(&xa, index, entry, GFP_KERNEL);
```

#### 查找条目

```c
/* 加载条目 */
void *entry = xa_load(&xa, index);
if (entry)
    printk("Found entry at index %d\n", index);

/* 查找并删除 */
void *entry = xa_erase(&xa, index);
if (entry)
    kfree(entry);
```

#### 遍历 XArray

```c
/* 遍历所有条目 */
unsigned long index;
void *entry;

xa_for_each(&xa, index, entry) {
    printk("index=%lu, entry=%p\n", index, entry);
}

/* 遍历范围 */
xa_for_each_range(&xa, index, entry, start, end) {
    printk("index=%lu\n", index);
}

/* 从指定位置开始 */
xa_for_each_start(&xa, index, entry, start) {
    printk("index=%lu\n", index);
}
```

#### 高级操作

```c
/* 分配一个空索引 */
unsigned int index = xa_alloc(&xa, entry, xa_limit_32b, GFP_KERNEL);

/* 标记条目（用于标记 PageDirty 等） */
xa_mark(&xa, index, XA_MARK_0);

/* 检查标记 */
if (xa_get_mark(&xa, index, XA_MARK_0))
    printk("Marked\n");

/* 查找下一个标记的条目 */
index = xa_find_marked(&xa, index, max, XA_MARK_0);
```

### 2.5 内核应用示例

#### 页缓存 (Page Cache)

```c
/* address_space 包含 XArray 存储所有页面 */
struct address_space {
    struct inode        *host;
    struct xarray       i_pages;   /* 页缓存 XArray */
    // ...
};

/* 查找页面 */
struct page *pagecache_get_page(struct address_space *mapping,
                                 pgoff_t index,
                                 int fgp_flags, gfp_t gfp_mask)
{
    struct page *page;

repeat:
    /* 从 XArray 查找页面 */
    page = xa_load(&mapping->i_pages, index);

    if (!page)
        return NULL;

    /* 处理换出页面 */
    if (!xa_is_value(page)) {
        /* 实际页面 */
        if (trylock_page(page)) {
            /* 成功锁定页面 */
        }
    }

    return page;
}

/* 添加页面到缓存 */
int add_to_page_cache_lru(struct page *page,
                          struct address_space *mapping,
                          pgoff_t index, gfp_t gfp_mask)
{
    /* 插入到 XArray */
    int error = xa_insert(&mapping->i_pages, index, page, gfp_mask);

    if (error == 0) {
        /* 添加到 LRU 链表 */
        lru_cache_add(page);
    }

    return error;
}
```

#### IRQ 描述符

```c
/* kernel/irq/irqdesc.c */

/* IRQ 描述符存储在 XArray 中 */
static DEFINE_XARRAY(irq_desc_trees[NR_IRQ_DESC_TREE_TYPES]);

struct irq_desc *irq_to_desc(unsigned int irq)
{
    struct xarray *xa = &irq_desc_trees[irq_desc_node(irq)];
    struct irq_desc *desc;

    rcu_read_lock();
    desc = xa_load(xa, irq);
    rcu_read_unlock();

    return desc;
}
```

---

## 三、Radix Tree vs XArray vs Red-Black Tree

| 特性           | Red-Black Tree        | Radix Tree  | XArray      |
|----------------|-----------------------|-------------|-------------|
| **查找复杂度** | O(log n)              | O(key bits) | O(key bits) |
| **范围查询**   | 支持                  | 不直接支持  | 部分支持    |
| **稀疏索引**   | 浪费内存              | 高效        | 高效        |
| **内存占用**   | 每节点 3 指针 + 颜色  | 动态        | 动态        |
| **并发**       | 需要外部锁            | 内部 RCU    | 内部 RCU    |
| **典型用途**   | VMA、CFS 调度         | 页缓存（旧）| 页缓存、IRQ |

---

## 四、选择建议

```
需要存储带序的数据？
├─ 需要范围查询？
│  └─ 使用红黑树 (VMA, CFS 调度)
│
├─ 索引是整数且可能稀疏？
│  ├─ 现代内核 → XArray (页缓存, IRQ)
│  └─ 旧内核 → Radix Tree
│
└─ 其他情况
   └─ 考虑哈希表
```

---

## 五、参考资料

- `include/linux/rbtree.h` - 红黑树 API
- `include/linux/rbtree_augmented.h` - 增强红黑树
- `include/linux/xarray.h` - XArray API
- `include/linux/radix-tree.h` - Radix Tree（已废弃）
- [Documentation/core-api/xarray.rst](https://www.kernel.org/doc/html/latest/core-api/xarray.html)
- [Red-Black Trees in Linux](https://www.kernel.org/doc/html/latest/core-api/rbtree.html)
