# 原子操作与位图 (Atomic & Bitmap)

## 一、原子操作 (Atomic Operations)

### 1.1 什么是原子操作

原子操作是**不可分割**的操作，执行过程中不会被中断，也不需要加锁。在多核系统中，
原子操作通过硬件指令（如 x86 的 `lock` 前缀）保证并发安全。

### 为什么需要原子操作？

```
非原子操作 (危险):
    counter = counter + 1;

编译后可能变成:
    temp = counter;     // 读
    temp = temp + 1;    // 加
    counter = temp;     // 写

多线程环境下可能丢失更新！

原子操作 (安全):
    atomic_inc(&counter);  // 一步完成
```

---

### 1.2 atomic_t - 原子整数

```c
#include <linux/atomic.h>

typedef struct {
    int counter;
} atomic_t;

/* 64 位版本 */
typedef struct {
    s64 counter;
} atomic64_t;
```

#### 定义和初始化

```c
/* 静态定义并初始化 */
atomic_t my_counter = ATOMIC_INIT(0);
atomic64_t my_counter64 = ATOMIC64_INIT(0);

/* 动态初始化 */
atomic_t my_counter;
atomic_set(&my_counter, 0);
atomic64_set(&my_counter64, 0);

/* 定义并初始化为特定值 */
DEFINE_ATOMIC(my_counter, 0);
```

#### 基本操作

```c
/* 读取 */
int value = atomic_read(&my_counter);
s64 value64 = atomic64_read(&my_counter64);

/* 设置 */
atomic_set(&my_counter, 10);
atomic64_set(&my_counter64, 100);

/* 增加 */
atomic_inc(&my_counter);        /* ++counter */
atomic_inc_return(&my_counter); /* ++counter, 返回新值 */

/* 减少 */
atomic_dec(&my_counter);        /* --counter */
atomic_dec_return(&my_counter); /* --counter, 返回新值 */

/* 加减 */
atomic_add(5, &my_counter);            /* counter += 5 */
atomic_add_return(5, &my_counter);     /* counter += 5, 返回新值 */
atomic_sub(3, &my_counter);            /* counter -= 3 */
atomic_sub_return(3, &my_counter);     /* counter -= 3, 返回新值 */
```

#### 条件操作

```c
/* 如果等于旧值，则设置为新值 */
int old = 1, new = 2;
atomic_cmpxchg(&my_counter, old, new);  /* 如果 counter==1, 则设为2 */

/* 如果条件成立则增加 */
int atomic_inc_not_zero(atomic_t *v);    /* 如果 != 0, 则 ++ */
int atomic_dec_and_test(atomic_t *v);    /* --, 检查是否 == 0 */
int atomic_inc_and_test(atomic_t *v);    /* ++, 检查是否 == 0 */
int atomic_sub_and_test(int i, atomic_t *v); /* -= i, 检查是否 == 0 */

/* 加减并测试负数 */
int atomic_add_negative(int i, atomic_t *v);  /* += i, 检查是否 < 0 */
int atomic_add_unless(atomic_t *v, int a, int u); /* 除非等于 u, 否则 += a */
```

---

### 1.3 refcount_t - 引用计数 (v4.11+)

引用计数有专门的数据类型，提供溢出检测：

```c
#include <linux/refcount.h>

struct refcount_struct {
    atomic_t refs;
};

/* 初始化 */
refcount_t ref = REFCOUNT_INIT(1);
refcount_set(&ref, 1);

/* 增加 */
refcount_inc(&ref);

/* 减少，返回是否为 0 */
bool zero = refcount_dec_and_test(&ref);

/* 检查 */
if (refcount_read(&ref) > 0) {
    /* 还有引用 */
}
```

---

### 1.4 原子位操作

```c
#include <linux/atomic.h>

/* 设置位 */
set_bit(nr, addr);        /* addr[nr] = 1 */
clear_bit(nr, addr);      /* addr[nr] = 0 */
change_bit(nr, addr);     /* addr[nr] = ~addr[nr] */

/* 测试位 */
bool test_bit(nr, addr);  /* 返回 addr[nr] 的值 */

/* 测试并设置 */
bool test_and_set_bit(nr, addr);   /* 设置位并返回旧值 */
bool test_and_clear_bit(nr, addr); /* 清除位并返回旧值 */
bool test_and_change_bit(nr, addr); /* 翻转位并返回旧值 */

/* 原子位操作（64 位） */
#define set_bit64(nr, addr)
#define clear_bit64(nr, addr)
```

---

### 1.5 内核应用示例

#### 引用计数管理

```c
struct my_data {
    refcount_t refcnt;
    int value;
};

/* 释放函数 */
static void my_data_release(struct kref *kref)
{
    struct my_data *data = container_of(kref, struct my_data, refcnt);

    kfree(data);
}

/* 获取引用 */
void my_data_get(struct my_data *data)
{
    refcount_inc(&data->refcnt);
}

/* 释放引用 */
void my_data_put(struct my_data *data)
{
    if (refcount_dec_and_test(&data->refcnt)) {
        kfree(data);
    }
}

/* 初始化 */
struct my_data *data = kmalloc(sizeof(*data), GFP_KERNEL);
refcount_set(&data->refcnt, 1);

/* 使用 */
my_data_get(data);
/* ... 使用 data ... */
my_data_put(data);
```

#### 模块引用计数

```c
/* 模块加载时 */
THIS_MODULE->state = MODULE_STATE_LIVE;

/* 增加模块引用计数 */
try_module_get(THIS_MODULE);

/* 减少模块引用计数 */
module_put(THIS_MODULE);
```

---

## 二、位图 (Bitmap)

### 2.1 什么是位图

位图是用**数组中的每一位**表示布尔值的紧凑数据结构。

```
bitmap[0] = 0b10110010
             │││││││└─ bit 0
             ││││││└── bit 1
             │││││└─── bit 2
             ││││└──── bit 3
             │││└───── bit 4
             ││└────── bit 5
             │└─────── bit 6
             └──────── bit 7
```

---

### 2.2 声明和初始化

```c
#include <linux/bitmap.h>

/* 静态声明 */
DECLARE_BITMAP(name, nbits);  /* unsigned long name[BITS_TO_LONGS(nbits)] */

/* 示例 */
DECLARE_BITMAP(my_bitmap, 64);  /* 64 位位图 */

/* 动态分配 */
unsigned long *bitmap = bitmap_alloc(nbits, GFP_KERNEL);
if (!bitmap)
    return -ENOMEM;

/* 释放 */
bitmap_free(bitmap);
```

---

### 2.3 基本操作

```c
/* 设置/清除位 */
bitmap_set(bitmap, start, nbits);      /* 设置从 start 开始的 nbits 位 */
bitmap_clear(bitmap, start, nbits);    /* 清除从 start 开始的 nbits 位 */

/* 单位操作 */
set_bit(bit, bitmap);         /* bitmap[bit] = 1 */
clear_bit(bit, bitmap);       /* bitmap[bit] = 0 */
change_bit(bit, bitmap);      /* bitmap[bit] = ~bitmap[bit] */

/* 测试位 */
bool test_bit(bit, bitmap);   /* 返回 bitmap[bit] */
bool test_and_set_bit(bit, bitmap);
bool test_and_clear_bit(bit, bitmap);

/* 查找位 */
int find_first_bit(bitmap, nbits);           /* 第一个 1 的位置 */
int find_first_zero_bit(bitmap, nbits);      /* 第一个 0 的位置 */
int find_next_bit(bitmap, nbits, offset);    /* 从 offset 开始找第一个 1 */
int find_next_zero_bit(bitmap, nbits, offset); /* 从 offset 开始找第一个 0 */

/* 复制 */
bitmap_copy(dst, src, nbits);

/* 填充 */
bitmap_fill(bitmap, nbits);     /* 全部设为 1 */
bitmap_zero(bitmap, nbits);     /* 全部设为 0 */

/* 逻辑运算 */
bitmap_and(dst, src1, src2, nbits);      /* dst = src1 & src2 */
bitmap_or(dst, src1, src2, nbits);       /* dst = src1 | src2 */
bitmap_xor(dst, src1, src2, nbits);      /* dst = src1 ^ src2 */
bitmap_andnot(dst, src1, src2, nbits);   /* dst = src1 & ~src2 */
bitmap_complement(dst, src, nbits);      /* dst = ~src */

/* 比较 */
bool bitmap_equal(src1, src2, nbits);
bool bitmap_intersects(src1, src2, nbits);  /* 是否有重叠的 1 */
bool bitmap_subset(src1, src2, nbits);      /* src1 是否是 src2 的子集 */
```

---

### 2.4 内核应用示例

#### CPU 掩码 (cpumask)

```c
#include <linux/cpumask.h>

/* CPU 0 和 CPU 1 */
cpumask_t my_mask;
cpumask_set_cpu(0, &my_mask);
cpumask_set_cpu(1, &my_mask);

/* 遍历 CPU */
for_each_cpu(cpu, &my_mask) {
    printk("CPU %d\n", cpu);
}

/* 检查 */
if (cpumask_test_cpu(cpu, &my_mask)) {
    printk("CPU %d is set\n", cpu);
}

/* 所有 CPU */
for_each_online_cpu(cpu) {
    printk("Online CPU: %d\n", cpu);
}
```

#### 节点掩码 (nodemask)

```c
#include <linux/nodemask.h>

/* 设置 NUMA 节点 */
nodemask_t my_nodes;
nodes_set(my_nodes);

/* 遍历节点 */
for_each_node(node) {
    printk("Node %d\n", node);
}

/* 检查 */
if (node_isset(node, my_nodes)) {
    printk("Node %d is set\n", node);
}
```

#### 内存位图

```c
/* 页分配器 */
struct zone {
    unsigned long *free_area[MAX_ORDER];
    // ...
};

/* 标记页面 */
bitmap_set(zone->free_area[order], start, 1);

/* 分配页面 */
int page = bitmap_find_free_region(bitmap, nbits, order);

/* 释放页面 */
bitmap_release_region(bitmap, start, order);
```

---

## 三、原子操作 vs 锁

| 特性 | 原子操作 | 锁 (spinlock/mutex) |
|------|---------|---------------------|
| **开销** | 极小 | 较大 |
| **复杂操作** | 不支持 | 支持 |
| **睡眠** | 不能 | mutex 可以 |
| **适用场景** | 简单计数/标志 | 复杂临界区 |

### 选择建议

```c
/* 好的原子操作使用 */
atomic_t refcnt = ATOMIC_INIT(1);
atomic_inc(&refcnt);
if (atomic_dec_and_test(&refcnt)) {
    kfree(obj);
}

/* 需要锁的情况 */
spin_lock(&lock);
list_add_tail(&obj->list, &head);
list_add_tail(&obj->another_list, &another);
update_counters(obj);
spin_unlock(&lock);
```

---

## 四、注意事项

### 4.1 原子操作不可混用

```c
/* 错误：原子操作和普通操作混用 */
atomic_set(&counter, 0);
counter.counter++;  /* 危险！ */

/* 正确 */
atomic_inc(&counter);
```

### 4.2 不要在原子操作中睡眠

```c
/* 错误：原子操作中不能睡眠 */
spin_lock(&lock);
    kmalloc(size, GFP_KERNEL);  /* 可能睡眠 */
spin_unlock(&lock);

/* 正确 */
spin_lock(&lock);
    GFP_ATOMIC 分配  /* 不睡眠 */
spin_unlock(&lock);
```

### 4.3 内存屏障

```c
/* 原子操作自带内存屏障，但有时需要显式屏障 */
smp_mb();   /* 完全内存屏障 */
smp_rmb();  /* 读内存屏障 */
smp_wmb();  /* 写内存屏障 */
```

---

## 五、参考资料

- `include/linux/atomic.h` - 原子操作 API
- `include/linux/refcount.h` - 引用计数
- `include/linux/bitmap.h` - 位图 API
- `include/linux/cpumask.h` - CPU 掩码
- `include/linux/nodemask.h` - NUMA 节点掩码
- [Kernel Atomic Operations](https://www.kernel.org/doc/html/latest/core-api/atomic_ops.html)
- [Bitmap API](https://www.kernel.org/doc/html/latest/core-api/bitmap.html)
