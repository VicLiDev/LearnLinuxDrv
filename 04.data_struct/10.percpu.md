# Per-CPU Variables (每 CPU 变量)

## 一、概述

Per-CPU 变量是为**每个 CPU 独立分配一份副本**的变量，用于避免伪共享（false sharing）
和减少锁竞争。

### 为什么需要 Per-CPU？

```
普通共享变量：
┌─────────────────────────────────────┐
│        shared_counter               │
│  CPU0 ──┐                           │
│  CPU1 ──┼──> 需要锁，缓存行竞争     │
│  CPU2 ──┤                           │
│  CPU3 ──┘                           │
└─────────────────────────────────────┘

Per-CPU 变量：
┌─────────┬─────────┬─────────┬─────────┐
│ CPU0    │ CPU1    │ CPU2    │ CPU3    │
│ counter │ counter │ counter │ counter │
│         │         │         │         │
│ 无锁访问│ 无锁访问│ 无锁访问│ 无锁访问│
└─────────┴─────────┴─────────┴─────────┘
```

---

## 二、静态分配 Per-CPU 变量

### 2.1 基本定义

```c
#include <linux/percpu.h>

/* 定义 Per-CPU 变量 */
DEFINE_PER_CPU(int, my_counter);
DEFINE_PER_CPU(struct my_struct, my_data);

/* 定义 Per-CPU 数组 */
DEFINE_PER_CPU(int[16], my_array);

/* 定义 Per-CPU 变量（未初始化）*/
DECLARE_PER_CPU(int, uninitialized_var);
```

### 2.2 访问 Per-CPU 变量

```c
/* 获取当前 CPU 的变量指针 */
int *counter = &__this_cpu_read(my_counter);

/* 读取当前 CPU 的值 */
int val = __this_cpu_read(my_counter);

/* 写入当前 CPU 的值 */
__this_cpu_write(my_counter, 42);

/* 加减操作 */
__this_cpu_inc(my_counter);
__this_cpu_dec(my_counter);
__this_cpu_add(my_counter, 10);
__this_cpu_sub(my_counter, 5);

/* 读取-修改-写入操作 */
int old = __this_cpu_xchg(my_counter, 100);
int old = __this_cpu_cmpxchg(my_counter, old, new);
```

### 2.3 带检查的访问

```c
/* 带抢占检查的访问（禁用抢占）*/
int val = this_cpu_read(my_counter);
this_cpu_write(my_counter, 42);
this_cpu_inc(my_counter);

/* 带特定 CPU 访问 */
int val = per_cpu(my_counter, cpu_id);
per_cpu(my_counter, cpu_id) = 42;
```

### 2.4 操作宏对比

| 宏                  | 抢占检查 | 用途         |
|---------------------|----------|--------------|
| `__this_cpu_read()` | 无       | 已知不会睡眠 |
| `this_cpu_read()`   | 有       | 默认使用     |
| `per_cpu(ptr, cpu)` | 无       | 访问指定 CPU |
| `raw_cpu_read()`    | 无       | 原始访问     |

---

## 三、动态分配 Per-CPU 变量

### 3.1 分配和释放

```c
#include <linux/percpu.h>

/* 分配 */
void *ptr = __alloc_percpu(size, alignment);
void *ptr = alloc_percpu(type);  /* sizeof(type) 和 __alignof__(type) */

/* 释放 */
free_percpu(ptr);
```

### 3.2 访问动态分配的变量

```c
struct my_data {
    int counter;
    spinlock_t lock;
};

/* 分配 */
struct my_data __percpu *data = alloc_percpu(struct my_data);
if (!data)
    return -ENOMEM;

/* 访问当前 CPU 的数据 */
struct my_data *local_data = this_cpu_ptr(data);
local_data->counter = 42;

/* 访问指定 CPU 的数据 */
int cpu = get_cpu();
struct my_data *other_data = per_cpu_ptr(data, cpu);
put_cpu();
```

---

## 四、完整示例

### 4.1 计数器示例

```c
#include <linux/module.h>
#include <linux/percpu.h>
#include <linux/kthread.h>
#include <linux/delay.h>

/* 静态 Per-CPU 计数器 */
static DEFINE_PER_CPU(int, cpu_counter);

/* 动态 Per-CPU 数据 */
struct percpu_data {
    int value;
    spinlock_t lock;
};

static struct percpu_data __percpu *my_data;

/* 工作线程 */
static int worker_thread(void *arg)
{
    int cpu = smp_processor_id();

    printk("Worker on CPU %d started\n", cpu);

    while (!kthread_should_stop()) {
        /* 增加 Per-CPU 计数器 */
        __this_cpu_inc(cpu_counter);

        /* 访问动态分配的数据 */
        struct percpu_data *data = this_cpu_ptr(my_data);
        data->value++;

        msleep(100);
    }

    printk("Worker on CPU %d: counter=%d\n",
           cpu, __this_cpu_read(cpu_counter));

    return 0;
}

static struct task_struct **workers;

static int __init my_init(void)
{
    int cpu;
    int num_cpus = num_online_cpus();

    /* 分配动态 Per-CPU 数据 */
    my_data = alloc_percpu(struct percpu_data);
    if (!my_data)
        return -ENOMEM;

    /* 初始化 */
    for_each_possible_cpu(cpu) {
        struct percpu_data *data = per_cpu_ptr(my_data, cpu);
        data->value = 0;
        spin_lock_init(&data->lock);
    }

    /* 为每个 CPU 创建工作线程 */
    workers = kmalloc_array(num_cpus, sizeof(*workers), GFP_KERNEL);
    if (!workers) {
        free_percpu(my_data);
        return -ENOMEM;
    }

    for_each_online_cpu(cpu) {
        workers[cpu] = kthread_create_on_cpu(worker_thread,
                                             NULL,
                                             cpu,
                                             "percpu_worker/%d");
    }

    return 0;
}

static void __exit my_exit(void)
{
    int cpu;
    int total = 0;

    /* 停止工作线程 */
    for_each_online_cpu(cpu) {
        kthread_stop(workers[cpu]);
    }

    /* 汇总所有 CPU 的计数 */
    for_each_possible_cpu(cpu) {
        int count = per_cpu(cpu_counter, cpu);
        total += count;
        printk("CPU %d: count=%d\n", cpu, count);
    }

    printk("Total count: %d\n", total);

    free_percpu(my_data);
    kfree(workers);
}

module_init(my_init);
module_exit(my_exit);
MODULE_LICENSE("GPL");
```

### 4.2 Per-CPU 统计

```c
/* 网络驱动中的 Per-CPU 统计 */
struct pcpu_sw_netstats {
    u64     rx_packets;
    u64     rx_bytes;
    u64     tx_packets;
    u64     tx_bytes;
    struct u64_stats_sync syncp;
};

static struct pcpu_sw_netstats __percpu *stats;

/* 接收包统计 */
void rx_packet(int len)
{
    struct pcpu_sw_netstats *s = this_cpu_ptr(stats);

    u64_stats_update_begin(&s->syncp);
    s->rx_packets++;
    s->rx_bytes += len;
    u64_stats_update_end(&s->syncp);
}

/* 获取总统计 */
void get_total_stats(u64 *rx_packets, u64 *rx_bytes)
{
    int cpu;
    u64 packets = 0, bytes = 0;

    for_each_possible_cpu(cpu) {
        struct pcpu_sw_netstats *s = per_cpu_ptr(stats, cpu);
        unsigned int start;
        u64 p, b;

        do {
            start = u64_stats_fetch_begin(&s->syncp);
            p = s->rx_packets;
            b = s->rx_bytes;
        } while (u64_stats_fetch_retry(&s->syncp, start));

        packets += p;
        bytes += b;
    }

    *rx_packets = packets;
    *rx_bytes = bytes;
}
```

---

## 五、Per-CPU 变量的用途

### 5.1 适用场景

| 场景           | 说明                 |
|----------------|----------------------|
| **高频计数器** | 中断处理、网络包统计 |
| **缓存数据**   | 减少 lock contention |
| **工作队列**   | 每个 CPU 的任务队列  |
| **VMstat**     | 虚拟内存统计         |

### 5.2 内核示例

```c
/* 中断计数器 */
DEFINE_PER_CPU_ALIGNED(struct irq_desc *, irq_desc);

/* 进程统计 */
DECLARE_PER_CPU(struct kernel_stat, kstat);

/* 网络统计 */
DEFINE_PER_CPU(struct pcpu_lstats, pcpu_lstats);

/* 块设备统计 */
struct blkcg_gq {
    struct percpu_counter __percpu *stat_arr[BLKCG_STAT_CNT];
};
```

---

## 六、对齐和缓存

### 6.1 缓存行对齐

```c
/* 默认对齐到缓存行（SMP） */
DEFINE_PER_CPU(int, counter);  /* 自动对齐 */

/* 强制对齐到指定边界 */
DEFINE_PER_CPU_ALIGNED(int[64], big_array);

/* 动态分配时指定对齐 */
void *ptr = __alloc_percpu(sizeof(struct my_data), __alignof__(struct my_data));
```

### 6.2 避免伪共享

```c
/* 错误：多个变量在同一缓存行 */
struct bad_example {
    int counter1;  /* 可能与 counter2 共享缓存行 */
    int counter2;
};
DEFINE_PER_CPU(struct bad_example, bad);

/* 正确：确保独立缓存行 */
struct good_example {
    int counter1;
    char pad1[L1_CACHE_BYTES - sizeof(int)];
    int counter2;
    char pad2[L1_CACHE_BYTES - sizeof(int)];
};
DEFINE_PER_CPU(struct good_example, good);
```

---

## 七、迁移和同步

### 7.1 CPU 热插拔

```c
#include <linux/cpuhotplug.h>

/* CPU 在线回调 */
static int my_cpu_online(unsigned int cpu)
{
    /* 初始化 Per-CPU 数据 */
    struct my_data *data = per_cpu_ptr(my_percpu_ptr, cpu);
    init_my_data(data);
    return 0;
}

/* CPU 离线回调 */
static int my_cpu_offline(unsigned int cpu)
{
    /* 清理 Per-CPU 数据 */
    struct my_data *data = per_cpu_ptr(my_percpu_ptr, cpu);
    cleanup_my_data(data);
    return 0;
}

/* 注册回调 */
static int __init my_init(void)
{
    cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,
                              "my_mod:online",
                              my_cpu_online,
                              my_cpu_offline);
    return 0;
}
```

### 7.2 汇总所有 CPU 的数据

```c
/* 方式1：简单相加 */
int sum = 0;
int cpu;

for_each_online_cpu(cpu) {
    sum += per_cpu(my_counter, cpu);
}

/* 方式2：使用 percpu_counter */
struct percpu_counter my_counter;  /* 64 位计数器 */

/* 初始化 */
percpu_counter_init(&my_counter, 0);

/* 增加 */
percpu_counter_inc(&my_counter);
percpu_counter_add(&my_counter, 10);

/* 获取当前值（近似）*/
s64 val = percpu_counter_read(&my_counter);

/* 获取精确值（慢）*/
s64 val = percpu_counter_sum(&my_counter);

/* 清理 */
percpu_counter_destroy(&my_counter);
```

---

## 八、调试技巧

```c
/* 打印所有 CPU 的 Per-CPU 变量 */
void dump_percpu_vars(void)
{
    int cpu;

    printk("Per-CPU counters:\n");
    for_each_possible_cpu(cpu) {
        printk("  CPU %d: %d\n", cpu, per_cpu(my_counter, cpu));
    }
}

/* 检查是否在正确的 CPU 上 */
void verify_cpu_access(void)
{
    int expected = smp_processor_id();
    int actual = get_cpu();
    BUG_ON(expected != actual);
    put_cpu();
}
```

---

## 九、注意事项

1. **指针混用**
   ```c
   /* 错误：混用不同 CPU 的指针 */
   int *ptr = this_cpu_ptr(&my_counter);
   put_cpu();
   /* 此时 ptr 已失效！ */

   /* 正确 */
   int *ptr = this_cpu_ptr(&my_counter);
   /* 使用 ptr */
   /* 不需要显式 put_cpu()，如果只是为了获取指针 */
   ```

2. **跨 CPU 访问**
   ```c
   /* 跨 CPU 访问需要额外同步 */
   int cpu = 2;
   spin_lock(&lock);  /* 可能需要 */
   per_cpu(my_var, cpu)++;
   spin_unlock(&lock);
   ```

3. **内存泄漏**
   ```c
   /* 记得释放 */
   void __percpu *ptr = alloc_percpu(type);
   /* ... */
   free_percpu(ptr);  /* 必须调用 */
   ```

4. **中断上下文**
   ```c
   /* 中断中可以安全使用 Per-CPU */
   irqreturn_t my_irq(int irq, void *dev)
   {
       __this_cpu_inc(irq_counter);
       return IRQ_HANDLED;
   }
   ```

---

## 十、参考资料

- `include/linux/percpu-defs.h` - Per-CPU 定义
- `include/linux/percpu.h` - Per-CPU API
- `Documentation/core-api/percpu-rw-semaphore.rst`
- [Per-CPU variables](https://www.kernel.org/doc/html/latest/core-api/percpu.html)
