# Notifier Chains (通知链)

## 一、概述

Notifier Chain（通知链）是 Linux 内核的一种**发布-订阅**机制，用于当**某个事件
发生时通知所有订阅者**。

### 为什么需要通知链？

```
传统方式（硬编码）:
  event_happened() {
      module_a_handler();
      module_b_handler();
      module_c_handler();
      // ... 需要修改代码来添加新的处理函数
  }

通知链方式:
  event_happened() {
      atomic_notifier_call_chain(&my_chain, 0, NULL);
      // 模块可以动态注册/注销
  }
```

---

## 二、Notifier Chain 类型

### 2.1 原子通知链

```c
#include <linux/notifier.h>

/* 定义原子通知链 */
ATOMIC_NOTIFIER_HEAD(my_chain);

/* 或者动态定义 */
struct atomic_notifier_head my_chain;
ATOMIC_INIT_NOTIFIER_HEAD(my_chain);
```

**特点**：
- 回调在原子上下文执行（不能睡眠）
- 使用 RCU 保护
- 适合中断、热插拔等场景

### 2.2 可阻塞通知链

```c
/* 定义可阻塞通知链 */
BLOCKING_NOTIFIER_HEAD(my_chain);

/* 或者动态定义 */
struct blocking_notifier_head my_chain;
BLOCKING_INIT_NOTIFIER_HEAD(my_chain);
```

**特点**：
- 回调可以睡眠
- 使用 RW 信号量保护
- 适合模块加载、设备事件等

### 2.3 原始通知链

```c
/* 定义原始通知链 */
RAW_NOTIFIER_HEAD(my_chain);

/* 或者动态定义 */
struct raw_notifier_head my_chain;
RAW_INIT_NOTIFIER_HEAD(my_chain);
```

**特点**：
- 无锁保护，调用者负责同步
- 灵活性最高

---

## 三、Notifier Callback

### 3.1 回调函数原型

```c
typedef int (*notifier_fn_t)(struct notifier_block *nb,
                              unsigned long action, void *data);

struct notifier_block {
    notifier_fn_t notifier_call;
    struct notifier_block __rcu *next;
    int priority;
};
```

### 3.2 回调返回值

```c
#define NOTIFY_DONE         0x0000  /* 不关心，继续通知 */
#define NOTIFY_OK           0x0001  /* 处理成功 */
#define NOTIFY_STOP         (NOTIFY_OK | NOTIFY_STOP_MASK)  /* 停止通知 */

static int my_notifier_cb(struct notifier_block *nb,
                          unsigned long action, void *data)
{
    printk("Event: %lu\n", action);
    return NOTIFY_OK;
}
```

---

## 四、基本操作

### 4.1 注册回调

```c
static struct notifier_block my_nb = {
    .notifier_call = my_notifier_cb,
    .priority = INT_MAX,
};

atomic_notifier_chain_register(&my_chain, &my_nb);
blocking_notifier_chain_register(&my_chain, &my_nb);
raw_notifier_chain_register(&my_chain, &my_nb);
```

### 4.2 注销回调

```c
atomic_notifier_chain_unregister(&my_chain, &my_nb);
blocking_notifier_chain_unregister(&my_chain, &my_nb);
raw_notifier_chain_unregister(&my_chain, &my_nb);
```

### 4.3 触发通知

```c
atomic_notifier_call_chain(&my_chain, event_val, data);
blocking_notifier_call_chain(&my_chain, event_val, data);
raw_notifier_call_chain(&my_chain, event_val, data);
```

---

## 五、内核标准通知链

| 通知链                 | 头文件              | 用途       | 类型   |
|------------------------|---------------------|------------|--------|
| `reboot_notifier_list` | `linux/reboot.h`    | 重启/关机  | 原子   |
| `cpu_chain`            | `linux/cpu.h`       | CPU 热插拔 | 原子   |
| `netdev_chain`         | `linux/netdevice.h` | 网络设备   | 可阻塞 |
| `panic_notifier_list`  | `linux/notifier.h`  | 内核 panic | 原子   |

### 使用示例

```c
/* 重启通知 */
static struct notifier_block reboot_nb;

static int reboot_handler(struct notifier_block *nb,
                          unsigned long action, void *data)
{
    if (action == SYS_RESTART)
        printk("System restarting!\n");
    return NOTIFY_OK;
}

static int __init my_init(void)
{
    reboot_nb.notifier_call = reboot_handler;
    register_reboot_notifier(&reboot_nb);
    return 0;
}

static void __exit my_exit(void)
{
    unregister_reboot_notifier(&reboot_nb);
}
```

---

## 六、注意事项

1. **原子通知链不能睡眠**
2. **优先级高的回调先执行**
3. **返回 NOTIFY_STOP 停止传播**
4. **注销后使用 synchronize_rcu() 等待**

---

## 七、参考资料

- `include/linux/notifier.h`
- [Notifier Chains](https://www.kernel.org/doc/html/latest/core-api/notifier.html)
