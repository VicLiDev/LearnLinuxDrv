# Kobject/Kset/Kref - 驱动模型核心

## 一、概述

Linux 内核驱动模型基于 `kobject`、`kset` 和 `kref` 构建。它们是/sys 文件系统和
设备管理的基础。

### 架构图

```
sysfs
  │
  ▼
kset (kobject 集合)
  │
  ├── kobject ──→ kref (引用计数)
  │     │
  │     ├── kobj_attribute (属性)
  │     └── sysfs_dirent (sysfs 目录)
  │
  └── kobject ...
```

---

## 二、kref - 引用计数

### 2.1 数据结构

```c
#include <linux/kref.h>

struct kref {
    atomic_t refcount;
};
```

### 2.2 基本操作

```c
/* 初始化 */
struct kref my_ref;
kref_init(&my_ref);

/* 增加引用 */
kref_get(&my_ref);

/* 减少引用，返回是否为 0 */
bool zero = kref_put(&my_ref, release_function);

/* 释放函数 */
static void release_function(struct kref *ref)
{
    struct my_struct *obj = container_of(ref, struct my_struct, ref);
    kfree(obj);
}
```

### 2.3 完整示例

```c
struct my_device {
    struct kref ref;
    int data;
};

/* 释放函数 */
static void my_device_release(struct kref *ref)
{
    struct my_device *dev = container_of(ref, struct my_device, ref);
    printk("Releasing device\n");
    kfree(dev);
}

/* 初始化 */
struct my_device *dev = kzalloc(sizeof(*dev), GFP_KERNEL);
kref_init(&dev->ref);

/* 获取引用 */
kref_get(&dev->ref);

/* 释放引用 */
if (kref_put(&dev->ref, my_device_release)) {
    /* refcount 到 0，已释放 */
}
```

---

## 三、kobject - 内核对象

### 3.1 数据结构

```c
#include <linux/kobject.h>

struct kobject {
    const char      *name;         /* 对象名称 */
    struct list_head    entry;     /* kset 中的链表 */
    struct kobject     *parent;    /* 父对象 */
    struct kset        *kset;      /* 所属 kset */
    struct kobj_type    *ktype;    /* 类型（属性和释放函数） */
    struct kernfs_node *sd;        /* sysfs 目录项 */
    struct kref      kref;         /* 引用计数 */
    // ...
};

struct kobj_type {
    void (*release)(struct kobject *kobj);
    const struct sysfs_ops *sysfs_ops;
    struct attribute **default_attrs;
    // ...
};
```

### 3.2 基本操作

```c
/* 初始化 */
void kobject_init(struct kobject *kobj, struct kobj_type *ktype);

/* 添加到 sysfs */
int kobject_add(struct kobject *kobj, struct kobject *parent,
                const char *fmt, ...);

/* 创建并添加 (一步完成) */
int kobject_init_and_add(struct kobject *kobj, struct kobj_type *ktype,
                         struct kobject *parent, const char *fmt, ...);

/* 删除 */
void kobject_del(struct kobject *kobj);

/* 释放引用 */
void kobject_put(struct kobject *kobj);

/* 获取引用 */
struct kobject *kobject_get(struct kobject *kobj);

/* 设置名称 */
int kobject_set_name(struct kobject *kobj, const char *fmt, ...);

/* 创建目录 */
struct kobject *kobject_create_and_add(const char *name,
                                       struct kobject *parent);
```

### 3.3 kobject 属性

```c
struct attribute {
    const char      *name;
    umode_t         mode;
};

struct kobj_attribute {
    struct attribute attr;
    ssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,
                    char *buf);
    ssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr,
                     const char *buf, size_t count);
};

/* 定义属性 */
static ssize_t my_attr_show(struct kobject *kobj, struct kobj_attribute *attr,
                            char *buf)
{
    return sprintf(buf, "42\n");
}

static ssize_t my_attr_store(struct kobject *kobj, struct kobj_attribute *attr,
                             const char *buf, size_t count)
{
    unsigned long val;
    if (kstrtoul(buf, 10, &val))
        return -EINVAL;
    /* 处理 val */
    return count;
}

/* 定义属性 */
static struct kobj_attribute my_attribute =
    __ATTR(my_value, 0664, my_attr_show, my_attr_store);

/* 属性数组 */
static struct attribute *my_attrs[] = {
    &my_attribute.attr,
    NULL,
};

/* kobj_type */
static struct kobj_type my_ktype = {
    .release = my_release,
    .sysfs_ops = &kobj_sysfs_ops,
    .default_attrs = my_attrs,
};
```

### 3.4 完整示例

```c
#include <linux/module.h>
#include <linux/kobject.h>
#include <linux/sysfs.h>

static struct kobject *my_kobj;
static int my_value = 42;

/* show 函数 */
static ssize_t value_show(struct kobject *kobj, struct kobj_attribute *attr,
                          char *buf)
{
    return sprintf(buf, "%d\n", my_value);
}

/* store 函数 */
static ssize_t value_store(struct kobject *kobj, struct kobj_attribute *attr,
                           const char *buf, size_t count)
{
    int ret;
    ret = kstrtoint(buf, 10, &my_value);
    if (ret)
        return ret;
    return count;
}

/* 定义属性 */
static struct kobj_attribute value_attr =
    __ATTR(value, 0664, value_show, value_store);

static struct attribute *my_attrs[] = {
    &value_attr.attr,
    NULL,
};

static struct kobj_type my_ktype = {
    .release = NULL,  /* 静态分配，不需要释放 */
    .sysfs_ops = &kobj_sysfs_ops,
    .default_attrs = my_attrs,
};

static int __init my_init(void)
{
    int ret;

    /* 创建 kobject */
    my_kobj = kobject_create_and_add("my_driver", kernel_kobj);
    if (!my_kobj)
        return -ENOMEM;

    /* 创建属性文件 */
    ret = sysfs_create_file(my_kobj, &value_attr.attr);
    if (ret)
        goto err;

    return 0;

err:
    kobject_put(my_kobj);
    return ret;
}

static void __exit my_exit(void)
{
    kobject_put(my_kobj);
}

module_init(my_init);
module_exit(my_exit);
MODULE_LICENSE("GPL");
```

---

## 四、kset - kobject 集合

### 4.1 数据结构

```c
struct kset {
    struct list_head list;       /* kobject 链表 */
    spinlock_t list_lock;        /* 保护链表 */
    struct kobject kobj;         /* 嵌入的 kobject */
    const struct kset_uevent_ops *uevent_ops;  /* 热插拔操作 */
};
```

### 4.2 基本操作

```c
/* 创建 kset */
struct kset *kset_create_and_add(const char *name,
                                 const struct kset_uevent_ops *u,
                                 struct kobject *parent);

/* 初始化 */
void kset_init(struct kset *kset);

/* 注册 */
int kset_register(struct kset *kset);

/* 注销 */
void kset_unregister(struct kset *kset);

/* 获取引用 */
struct kset *kset_get(struct kset *kset);

/* 释放引用 */
void kset_put(struct kset *kset);
```

### 4.3 kset 示例

```c
static struct kset *my_kset;

static int __init my_init(void)
{
    /* 创建 kset */
    my_kset = kset_create_and_add("my_devices", NULL, kernel_kobj);
    if (!my_kset)
        return -ENOMEM;

    /* 创建 kobject 并加入 kset */
    struct kobject *kobj = kobject_create();
    if (!kobj) {
        kset_unregister(my_kset);
        return -ENOMEM;
    }

    kobj->kset = my_kset;
    kobject_init(kobj, &my_ktype);
    kobject_add(kobj, NULL, "device1");

    return 0;
}

static void __exit my_exit(void)
{
    kset_unregister(my_kset);
}
```

---

## 五、内核应用示例

### 5.1 设备驱动模型

```c
/* 设备核心结构 */
struct device {
    struct kobject      kobj;
    struct device       *parent;
    struct device_driver *driver;
    // ...
};

/* 驱动核心结构 */
struct device_driver {
    const char      *name;
    struct bus_type     *bus;
    struct module       *owner;
    const char      *mod_name;
    // ...
};

/* 总线类型 */
struct bus_type {
    const char      *name;
    struct kset     *drivers_kset;
    struct kset     *devices_kset;
    // ...
};

/* 注册设备 */
int device_register(struct device *dev)
{
    /* device_initialize() 初始化 kobject */
    /* device_add() 添加到 sysfs */
}

/* 注册驱动 */
int driver_register(struct device_driver *drv)
{
    /* bus_add_driver() 添加到总线的 drivers_kset */
}
```

### 5.2 sysfs 目录结构

```
/sys/
├── devices/          (kset)
│   ├── platform/     (kset)
│   │   └── serial8250.0  (kobject)
│   └── system/       (kset)
│       └── my_device/    (kobject)
│           ├── power/   (kobject)
│           └── subsystem    (symlink)
│
├── bus/              (kset)
│   ├── platform/     (kset)
│   │   ├── drivers/  (kset)
│   │   │   └── my_driver
│   │   └── devices/  (kset)
│   │       └── my_device
│
└── kernel/           (kset)
    └── my_driver/    (kobject)
        └── value     (attribute file)
```

---

## 六、调试技巧

```c
/* 打印 kobject 信息 */
void kobject_info(struct kobject *kobj)
{
    printk("kobj: %s\n", kobject_name(kobj));
    printk("  parent: %s\n", kobj->parent ? kobject_name(kobj->parent) : "none");
    printk("  kset: %s\n", kobj->kset ? kobj->kset->kobj.name : "none");
    printk("  refcount: %d\n", kref_read(&kobj->kref));
}

/* 遍历 kset 中的所有 kobject */
struct kobject *kobj;
spin_lock(&kset->list_lock);
list_for_each_entry(kobj, &kset->list, entry) {
    printk("  %s\n", kobject_name(kobj));
}
spin_unlock(&kset->list_lock);
```

---

## 七、注意事项

1. **引用计数平衡**
   ```c
   /* 每次 get 必须有对应的 put */
   kobject_get(kobj);
   /* ... 使用 kobj ... */
   kobject_put(kobj);
   ```

2. **生命周期管理**
   ```c
   /* 错误：在 release 后访问 */
   kobject_put(kobj);
   kobject_name(kobj);  /* 危险！可能已释放 */

   /* 正确：在 put 前完成所有操作 */
   kobject_name(kobj);
   kobject_put(kobj);
   ```

3. **命名规则**
   ```c
   /* 名称不能包含 '/' */
   kobject_set_name(kobj, "my/device");  /* 错误！ */
   kobject_set_name(kobj, "my-device");  /* 正确 */
   ```

4. **并发安全**
   ```c
   /* kobject 操作有自己的锁，但数据结构需要额外保护 */
   spin_lock(&my_lock);
   my_data++;
   spin_unlock(&my_lock);
   ```

---

## 八、参考资料

- `include/linux/kobject.h` - kobject API
- `include/linux/kref.h` - kref API
- `Documentation/kobject.txt` - kobject 文档
- [Driver Model](https://www.kernel.org/doc/html/latest/driver-api/driver-model/)
