# Gen Pool / Memory Pool (内存池)

## 一、概述

Gen Pool（通用内存池）是内核提供的一种**固定大小内存池**管理机制，用于快速分配和
释放固定大小的内存块。

### 为什么需要内存池？

```
普通分配（kmalloc）：
  - 每次分配需要查找合适大小
  - 可能耗时较长
  - 产生内存碎片

内存池（Memory Pool）：
  - 预先分配一大块内存
  - 固定大小分配，速度快
  - 无碎片
  - 适合频繁分配/释放相同大小对象
```

---

## 二、Gen Pool API

### 2.1 数据结构

```c
#include <linux/genalloc.h>

struct gen_pool {
    spinlock_t lock;
    struct list_head chunks;   /* 内存块链表 */
    int min_alloc_order;       /* 最小分配 order (2^order 字节) */
    unsigned long algo;        /* 分配算法 */
    void *data;
};
```

### 2.2 创建和销毁

```c
/* 创建内存池 */
struct gen_pool *gen_pool_create(int min_alloc_order, int nid);

/* min_alloc_order: 最小分配的 order (2^order 字节)
 * nid: NUMA 节点 ID
 */

/* 添加内存到池 */
int gen_pool_add(struct gen_pool *pool, unsigned long addr,
                 size_t size, int nid);

/* 从现有内存创建池（新 API）*/
struct gen_pool *gen_pool_get(struct gen_pool *pool, unsigned long addr);
void gen_pool_put(struct gen_pool *pool);

/* 销毁内存池 */
void gen_pool_destroy(struct gen_pool *pool);
```

### 2.3 分配和释放

```c
/* 分配 */
unsigned long gen_pool_alloc(struct gen_pool *pool, size_t size);
unsigned long gen_pool_alloc_algo(struct gen_pool *pool, size_t size,
                                   genpool_algo_t algo, void *data);

/* 带等待的分配 */
unsigned long gen_pool_alloc_owner(struct gen_pool *pool, size_t size);

/* 释放 */
void gen_pool_free(struct gen_pool *pool, unsigned long addr, size_t size);

/* 查询 */
bool gen_pool_has_addr(struct gen_pool *pool, unsigned long start,
                        size_t size);

/* 获取可用大小 */
size_t gen_pool_avail(struct gen_pool *pool);

/* 获取总大小 */
size_t gen_pool_size(struct gen_pool *pool);
```

---

## 三、完整示例

### 3.1 基本 Gen Pool

```c
#include <linux/module.h>
#includelinux/genalloc.h>
#include <linux/slab.h>

static struct gen_pool *my_pool;
static void *pool_memory;

static int __init my_init(void)
{
    int ret;
    unsigned long addr;

    /* 创建内存池，最小分配 32 字节 (2^5) */
    my_pool = gen_pool_create(5, -1);
    if (!my_pool)
        return -ENOMEM;

    /* 分配 1MB 物理连续内存 */
    pool_memory = kmalloc(SZ_1M, GFP_KERNEL);
    if (!pool_memory) {
        gen_pool_destroy(my_pool);
        return -ENOMEM;
    }

    /* 添加到内存池 */
    ret = gen_pool_add(my_pool, (unsigned long)pool_memory, SZ_1M, -1);
    if (ret) {
        kfree(pool_memory);
        gen_pool_destroy(my_pool);
        return ret;
    }

    /* 分配一些内存 */
    addr = gen_pool_alloc(my_pool, 128);
    if (!addr) {
        printk("Failed to allocate from pool\n");
        return -ENOMEM;
    }
    printk("Allocated: 0x%lx (128 bytes)\n", addr);

    /* 使用内存 */
    memset((void *)addr, 0xAA, 128);

    /* 释放 */
    gen_pool_free(my_pool, addr, 128);

    printk("Pool stats: avail=%zu, total=%zu\n",
           gen_pool_avail(my_pool),
           gen_pool_size(my_pool));

    return 0;
}

static void __exit my_exit(void)
{
    if (my_pool) {
        gen_pool_destroy(my_pool);
        kfree(pool_memory);
    }
}

module_init(my_init);
module_exit(my_exit);
MODULE_LICENSE("GPL");
```

### 3.2 驱动中使用 Gen Pool

```c
/* 驱动私有内存池 */
struct my_driver {
    struct gen_pool *pool;
    size_t buf_size;
};

static int my_driver_probe(struct platform_device *pdev)
{
    struct my_driver *drv;
    struct resource *res;
    unsigned long addr;
    int ret;

    drv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);
    if (!drv)
        return -ENOMEM;

    /* 获取保留内存 */
    res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "memory");
    if (!res)
        return -ENODEV;

    /* 创建内存池 */
    drv->pool = gen_pool_create(ilog2(SZ_4K), dev_to_node(&pdev->dev));
    if (!drv->pool)
        return -ENOMEM;

    /* 添加保留内存到池 */
    ret = gen_pool_add(drv->pool, res->start, resource_size(res),
                       dev_to_node(&pdev->dev));
    if (ret) {
        gen_pool_destroy(drv->pool);
        return ret;
    }

    drv->buf_size = SZ_1M;

    /* 从池中分配 DMA 缓冲区 */
    addr = gen_pool_alloc(drv->pool, drv->buf_size);
    if (!addr) {
        gen_pool_destroy(drv->pool);
        return -ENOMEM;
    }

    dev_info(&pdev->dev, "Allocated buffer: 0x%lx\n", addr);

    platform_set_drvdata(pdev, drv);
    return 0;
}

static int my_driver_remove(struct platform_device *pdev)
{
    struct my_driver *drv = platform_get_drvdata(pdev);

    gen_pool_destroy(drv->pool);

    return 0;
}
```

---

## 四、DMA Pool

### 4.1 DMA Pool API

```c
#include <linux/dmapool.h>

/* 创建 DMA 池 */
struct dma_pool *dma_pool_create(const char *name,
                                  struct device *dev,
                                  size_t size,
                                  size_t align,
                                  size_t allocation);

/* name: 池名称
 * dev: 设备
 * size: 每个对象的大小
 * align: 对齐要求（0 = 默认）
 * allocation: 边界限制（0 = 无限制）
 */

/* 分配 */
void *dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,
                     dma_addr_t *handle);

/* 释放 */
void dma_pool_free(struct dma_pool *pool, void *vaddr,
                   dma_addr_t addr);

/* 销毁 */
void dma_pool_destroy(struct dma_pool *pool);
```

### 4.2 DMA Pool 示例

```c
#include <linux/dmapool.h>

struct my_device {
    struct dma_pool *desc_pool;
    struct dma_pool *data_pool;
};

static int my_device_init(struct my_device *dev)
{
    /* 创建描述符池（32 字节，32 字节对齐）*/
    dev->desc_pool = dma_pool_create("desc_pool", dev->dev,
                                      32, 32, 0);
    if (!dev->desc_pool)
        return -ENOMEM;

    /* 创建数据池（1KB，缓存行对齐）*/
    dev->data_pool = dma_pool_create("data_pool", dev->dev,
                                      SZ_1K, L1_CACHE_BYTES, 0);
    if (!dev->data_pool) {
        dma_pool_destroy(dev->desc_pool);
        return -ENOMEM;
    }

    return 0;
}

static void my_device_cleanup(struct my_device *dev)
{
    dma_pool_destroy(dev->desc_pool);
    dma_pool_destroy(dev->data_pool);
}

/* 分配描述符 */
static struct desc *alloc_desc(struct my_device *dev)
{
    dma_addr_t dma_handle;
    struct desc *desc;

    desc = dma_pool_alloc(dev->desc_pool, GFP_KERNEL, &dma_handle);
    if (!desc)
        return NULL;

    desc->dma_addr = dma_handle;
    return desc;
}

/* 释放描述符 */
static void free_desc(struct my_device *dev, struct desc *desc)
{
    dma_pool_free(dev->desc_pool, desc, desc->dma_addr);
}
```

---

## 五、Mempool

### 5.1 Mempool API

```c
#include <linux/mempool.h>

/* 定义内存池对象 */
typedef mempool_t;

/* 创建内存池 */
mempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn,
                           mempool_free_t *free_fn, void *pool_data);

/* min_nr: 最小保留的对象数
 * alloc_fn: 分配函数
 * free_fn: 释放函数
 * pool_data: 传递给分配/释放函数的数据
 */

/* 使用 kmalloc/kfree 的快捷方式 */
mempool_t *mempool_create_kmalloc_pool(int min_nr, size_t size);

/* 分配 */
void *mempool_alloc(mempool_t *pool, gfp_t gfp_mask);

/* 释放 */
void mempool_free(void *element, mempool_t *pool);

/* 销毁 */
void mempool_destroy(mempool_t *pool);

/* 重新调整大小 */
int mempool_resize(mempool_t *pool, int new_min_nr);
```

### 5.2 Mempool 示例

```c
#include <linux/mempool.h>

struct my_driver {
    mempool_t *req_pool;
};

/* 自定义分配/释放函数 */
static void *req_alloc(gfp_t gfp_mask, void *pool_data)
{
    struct my_device *dev = pool_data;
    return kmalloc(sizeof(struct request), gfp_mask);
}

static void req_free(void *element, void *pool_data)
{
    kfree(element);
}

static int my_driver_init(struct my_device *dev)
{
    /* 创建内存池，最小保留 16 个对象 */
    dev->req_pool = mempool_create(16, req_alloc, req_free, dev);
    if (!dev->req_pool)
        return -ENOMEM;

    return 0;
}

/* 分配请求 */
static struct request *alloc_request(struct my_device *dev)
{
    return mempool_alloc(dev->req_pool, GFP_KERNEL);
}

/* 释放请求 */
static void free_request(struct my_device *dev, struct request *req)
{
    mempool_free(req, dev->req_pool);
}
```

---

## 六、内存池对比

| 类型           | 用途         | 分配大小 | 来源              |
|----------------|--------------|----------|-------------------|
| **gen_pool**   | 通用内存池   | 任意     | 预分配内存        |
| **dma_pool**   | DMA 一致内存 | 固定     | DMA coherent 内存 |
| **mempool**    | 对象缓存     | 固定     | kmalloc/slab      |
| **kmem_cache** | Slab 分配器  | 固定     | slab allocator    |

---

## 七、典型应用

### 7.1 网络驱动

```c
/* 网络包描述符池 */
static struct dma_pool *tx_desc_pool;
static struct dma_pool *rx_desc_pool;

/* 初始化 */
tx_desc_pool = dma_pool_create("tx_desc", dev->dev,
                                 sizeof(struct tx_desc), 64, 0);
rx_desc_pool = dma_pool_create("rx_desc", dev->dev,
                                 sizeof(struct rx_desc), 64, 0);

/* 快速分配描述符 */
struct tx_desc *desc = dma_pool_alloc(tx_desc_pool, GFP_ATOMIC, &dma_addr);
```

### 7.2 块设备驱动

```c
/* 请求池 */
static mempool_t *req_mempool;

/* 创建池 */
req_mempool = mempool_create_kmalloc_pool(32, sizeof(struct request));

/* 分配请求（保证不会失败）*/
struct request *req = mempool_alloc(req_mempool, GFP_NOIO);
```

### 7.3 文件系统

```c
/* inode 缓存池 */
static struct kmem_cache *inode_cache;

/* 创建 slab 缓存 */
inode_cache = kmem_cache_create("myfs_inode",
                                  sizeof(struct myfs_inode),
                                  0, SLAB_RECLAIM_ACCOUNT,
                                  NULL);

/* 分配 */
struct myfs_inode *inode = kmem_cache_alloc(inode_cache, GFP_KERNEL);

/* 释放 */
kmem_cache_free(inode_cache, inode);
```

---

## 八、调试技巧

```c
/* 打印内存池状态 */
void dump_gen_pool(struct gen_pool *pool)
{
    printk("Pool stats:\n");
    printk("  Available: %zu bytes\n", gen_pool_avail(pool));
    printk("  Total: %zu bytes\n", gen_pool_size(pool));
    printk("  Used: %zu bytes\n",
           gen_pool_size(pool) - gen_pool_avail(pool));
}

/* DMA 池统计 */
void dump_dma_pool(struct dma_pool *pool)
{
    printk("DMA pool '%s':\n", pool->name);
}
```

---

## 九、注意事项

1. **选择合适的池类型**
   ```c
   /* DMA 内存用 dma_pool */
   dma_pool_create(...);

   /* 对象缓存用 mempool */
   mempool_create(...);

   /* 通用内存管理用 gen_pool */
   gen_pool_create(...);
   ```

2. **对齐要求**
   ```c
   /* 确保满足设备的对齐要求 */
   pool = dma_pool_create("pool", dev, size, 64, 0);  /* 64 字节对齐 */
   ```

3. **错误处理**
   ```c
   /* mempool_alloc 在紧急情况下可能睡眠 */
   void *obj = mempool_alloc(pool, GFP_NOIO);  /* 不会失败 */
   ```

4. **销毁顺序**
   ```c
   /* 先释放所有分配的对象，再销毁池 */
   gen_pool_free(pool, addr, size);
   gen_pool_destroy(pool);
   ```

---

## 十、参考资料

- `include/linux/genalloc.h` - Gen Pool API
- `include/linux/dmapool.h` - DMA Pool API
- `include/linux/mempool.h` - Mempool API
- `include/linux/slab.h` - Slab Allocator
- [Memory Management](https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html)
