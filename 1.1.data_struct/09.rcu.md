# RCU (Read-Copy-Update)

## 一、概述

RCU (Read-Copy-Update) 是一种高性能的**无锁读取**同步机制，特别适合读多写少的场景。

### RCU 原理

```
传统读写锁：
  读操作：需要加锁，阻止并发写
  写操作：需要加锁，阻止并发读写
  问题：读者之间也互斥，扩展性差

RCU：
  读操作：完全无锁，多个读者可并发执行
  写操作：复制数据，修改副本，延迟释放旧数据
  优势：读者零开销，扩展性好
```

### 关键概念

```
┌─────────────────────────────────────┐
│           Grace Period              │
│  (所有已存在的读者完成读取的时间)   │
└─────────────────────────────────────┘

写操作流程：
1. 复制数据
2. 修改副本
3. 原子替换指针
4. 等待 Grace Period
5. 释放旧数据

读者在 Grace Period 期间继续访问旧数据
```

---

## 二、RCU 基本操作

### 2.1 读者侧（无锁读取）

```c
#include <linux/rcupdate.h>

/* 进入 RCU 读者临界区 */
rcu_read_lock();
/* 读取共享数据 */
rcu_read_unlock();

/* 或者使用特定版本 */
rcu_read_lock_bh();   /* 禁用底半部 */
rcu_read_lock_sched(); /* 禁用抢占 */
```

### 2.2 写者侧（带锁更新）

```c
#include <linux/rcupdate.h>

/* 等待所有已存在的读者完成 */
synchronize_rcu();       /* 可能睡眠 */
synchronize_rcu_expedited();  /* 快速版本 */

/* 调度回调在 Grace Period 后执行 */
call_rcu(&head->rcu, callback);  /* 不能睡眠 */
call_rcu_bh(&head->rcu, callback);
call_rcu_sched(&head->rcu, callback);
```

---

## 三、RCU 版本数据结构

### 3.1 RCU 保护的链表

```c
#include <linux/rculist.h>

/* 定义数据结构 */
struct my_data {
    int value;
    struct list_head list;  /* 普通链表节点 */
    struct rcu_head rcu;    /* RCU 回调头 */
};

/* 遍历（读者，无锁）*/
struct my_data *pos;
rcu_read_lock();
list_for_each_entry_rcu(pos, &head, list) {
    printk("value=%d\n", pos->value);
}
rcu_read_unlock();

/* 添加节点（写者，加锁）*/
spin_lock(&lock);
list_add_rcu(&new_node->list, &head);
spin_unlock(&lock);

/* 删除节点（写者，加锁）*/
spin_lock(&lock);
list_del_rcu(&old_node->list);
spin_unlock(&lock);

/* 延迟释放 */
call_rcu(&old_node->rcu, my_free_callback);
```

### 3.2 RCU 保护的指针

```c
#include <linux/rcupdate.h>

/* 定义全局指针 */
static struct my_data *global_ptr __rcu;

/* 读取（读者）*/
rcu_read_lock();
struct my_data *ptr = rcu_dereference(global_ptr);
if (ptr) {
    /* 访问 ptr */
    printk("value=%d\n", ptr->value);
}
rcu_read_unlock();

/* 更新（写者）*/
struct my_data *new_ptr = kmalloc(sizeof(*new_ptr), GFP_KERNEL);
new_ptr->value = 42;

spin_lock(&lock);
struct my_data *old_ptr = rcu_replace_pointer(global_ptr, new_ptr, lock);
spin_unlock(&lock);

/* 释放旧指针 */
if (old_ptr)
    call_rcu(&old_ptr->rcu, my_free_callback);
```

### 3.3 RCU 哈希表

```c
#include <linux/rculist.h>
#include <linux/hashtable.h>

/* 定义 */
static DEFINE_HASHTABLE(my_hash, 8);
static DEFINE_SPINLOCK(hash_lock);

struct hash_entry {
    int key;
    int value;
    struct hlist_node node;
    struct rcu_head rcu;
};

/* 查找（读者，无锁）*/
struct hash_entry *entry;
unsigned int hash = key % HASH_SIZE(my_hash);

rcu_read_lock();
hash_for_each_possible_rcu(my_hash, entry, node, hash) {
    if (entry->key == key) {
        printk("Found: value=%d\n", entry->value);
        break;
    }
}
rcu_read_unlock();

/* 插入（写者，加锁）*/
spin_lock(&hash_lock);
hash_add_rcu(my_hash, &new_entry->node, new_entry->key);
spin_unlock(&hash_lock);

/* 删除（写者，加锁）*/
spin_lock(&hash_lock);
hash_del_rcu(&entry->node);
spin_unlock(&hash_lock);

call_rcu(&entry->rcu, entry_free_callback);
```

---

## 四、完整示例

### 4.1 RCU 链表示例

```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/rcupdate.h>
#include <linux/slab.h>
#include <linux/spinlock.h>
#include <linux/kthread.h>

struct my_node {
    int data;
    struct list_head list;
    struct rcu_head rcu;
};

static LIST_HEAD(head);
static DEFINE_SPINLOCK(lock);

/* RCU 回调函数 */
static void my_node_free(struct rcu_head *rcu)
{
    struct my_node *node = container_of(rcu, struct my_node, rcu);
    printk("Freeing node: data=%d\n", node->data);
    kfree(node);
}

/* 读者线程 */
static int reader_thread(void *data)
{
    struct my_node *pos;

    while (!kthread_should_stop()) {
        rcu_read_lock();
        list_for_each_entry_rcu(pos, &head, list) {
            printk("Reader sees: data=%d\n", pos->data);
        }
        rcu_read_unlock();

        msleep(100);
    }

    return 0;
}

/* 写者线程 */
static int writer_thread(void *data)
{
    int count = 0;

    while (!kthread_should_stop()) {
        /* 添加新节点 */
        struct my_node *new_node = kmalloc(sizeof(*new_node), GFP_KERNEL);
        if (new_node) {
            new_node->data = count++;

            spin_lock(&lock);
            list_add_rcu(&new_node->list, &head);
            spin_unlock(&lock);

            printk("Writer added: data=%d\n", new_node->data);
        }

        msleep(500);
    }

    return 0;
}

static struct task_struct *reader_task;
static struct task_struct *writer_task;

static int __init my_init(void)
{
    reader_task = kthread_run(reader_thread, NULL, "rcu_reader");
    writer_task = kthread_run(writer_thread, NULL, "rcu_writer");

    return 0;
}

static void __exit my_exit(void)
{
    struct my_node *pos, *tmp;

    if (reader_task)
        kthread_stop(reader_task);
    if (writer_task)
        kthread_stop(writer_task);

    /* 清理所有节点 */
    list_for_each_entry_safe(pos, tmp, &head, list) {
        list_del_rcu(&pos->list);
        call_rcu(&pos->rcu, my_node_free);
    }

    /* 等待所有回调完成 */
    rcu_barrier();
}

module_init(my_init);
module_exit(my_exit);
MODULE_LICENSE("GPL");
```

### 4.2 RCU 指针示例

```c
#include <linux/module.h>
#include <linux/rcupdate.h>
#include <linux/spinlock.h>
#include <linux/slab.h>
#include <linux/delay.h>

struct config {
    int interval;
    char name[32];
    struct rcu_head rcu;
};

static struct config *global_config __rcu;
static DEFINE_SPINLOCK(config_lock);

/* 释放回调 */
static void config_free_rcu(struct rcu_head *rcu)
{
    struct config *cfg = container_of(rcu, struct config, rcu);
    printk("Freeing old config: %s, interval=%d\n",
           cfg->name, cfg->interval);
    kfree(cfg);
}

/* 读取配置（无锁）*/
void read_config(void)
{
    struct config *cfg;

    rcu_read_lock();
    cfg = rcu_dereference(global_config);
    if (cfg) {
        printk("Config: %s, interval=%d\n", cfg->name, cfg->interval);
    }
    rcu_read_unlock();
}

/* 更新配置（加锁）*/
void update_config(int new_interval, const char *new_name)
{
    struct config *new_cfg, *old_cfg;

    new_cfg = kzalloc(sizeof(*new_cfg), GFP_KERNEL);
    if (!new_cfg)
        return;

    new_cfg->interval = new_interval;
    strscpy(new_cfg->name, new_name, sizeof(new_cfg->name));

    spin_lock(&config_lock);
    old_cfg = rcu_replace_pointer(global_config, new_cfg, config_lock);
    spin_unlock(&config_lock);

    printk("Config updated: %s, interval=%d\n", new_name, new_interval);

    /* 释放旧配置 */
    if (old_cfg)
        call_rcu(&old_cfg->rcu, config_free_rcu);
}
```

---

## 五、RCU 变种

### 5.1 RCU 类型对比

| 类型                    | 用途       | 读者开销 | Grace Period            |
|-------------------------|------------|----------|-------------------------|
| `rcu_read_lock()`       | 默认       | 无       | 等待所有 CPU 上下文切换 |
| `rcu_read_lock_bh()`    | 网络包处理 | 无       | 等待所有 CPU 的底半部   |
| `rcu_read_lock_sched()` | 调度器     | 无       | 等待所有 CPU 调度       |
| `srcu_read_lock()`      | 需要睡眠   | 低       | 等待特定 SRCU 域        |

### 5.2 SRCU (Sleepable RCU)

```c
#include <linux/srcu.h>

/* 定义 SRCU 域 */
DEFINE_SRCU(my_srcu);
/* 或动态初始化 */
struct srcu_struct my_srcu;
init_srcu_struct(&my_srcu);

/* 读者（可以睡眠）*/
int idx;
idx = srcu_read_lock(&my_srcu);
/* 可以睡眠 */
msleep(100);
srcu_read_unlock(&my_srcu, idx);

/* 写者 */
synchronize_srcu(&my_srcu);  /* 等待所有读者 */
/* 或 */
call_srcu(&my_srcu, &head->rcu, callback);

/* 清理 */
cleanup_srcu_struct(&my_srcu);
```

---

## 六、何时使用 RCU

### 适合 RCU 的场景

| 条件           | 说明                   |
|----------------|------------------------|
| **读多写少**   | 读者远多于写者         |
| **读操作快速** | 读者临界区短，不能睡眠 |
| **数据结构小** | 复制开销可接受         |
| **可容忍延迟** | 旧数据可以存活一段时间 |

### 不适合 RCU 的场景

| 条件             | 原因             | 替代方案          |
|------------------|------------------|-------------------|
| **写操作频繁**   | 每次 copy 开销大 | 读写锁            |
| **读者需要睡眠** | RCU 读者不能睡眠 | SRCU 或 rwlock    |
| **数据结构大**   | 复制开销大       | 引用计数 + rwlock |
| **需要立即释放** | RCU 延迟释放     | 锁 + 立即释放     |

---

## 七、调试技巧

```c
/* 检查 RCU 读者临界区 */
rcu_read_lock();
/* 你的代码 */
WARN_ON_ONCE(!rcu_read_lock_held());
rcu_read_unlock();

/* 调试 RCU 指针访问 */
rcu_read_lock();
ptr = rcu_dereference(global_ptr);
/* 检查是否在 RCU 临界区 */
WARN_ON_ONCE(!rcu_read_lock_held());
rcu_read_unlock();

/* 检查 SRCU 读者临界区 */
idx = srcu_read_lock(&my_srcu);
WARN_ON_ONCE(!srcu_read_lock_held(&my_srcu));
srcu_read_unlock(&my_srcu, idx);

/* RCU stall 检测 */
/* 内核会在 RCU stall 时打印诊断信息 */
```

---

## 八、性能考虑

### 8.1 读者零开销

```c
/* 传统读写锁 */
read_lock(&lock);  /* 原子操作，有开销 */
/* 读取数据 */
read_unlock(&lock);

/* RCU */
rcu_read_lock();   /* 通常只是 barrier，无开销 */
/* 读取数据 */
rcu_read_unlock(); /* 通常只是 barrier，无开销 */
```

### 8.2 写者开销

```c
/* 更新 RCU 保护的指针 */
spin_lock(&lock);  /* 加锁 */
new_ptr = copy_and_modify(old_ptr);  /* 复制开销 */
rcu_assign_pointer(global, new_ptr);  /* 原子操作 */
spin_unlock(&lock);

call_rcu(&old_ptr->rcu, free_func);  /* 延迟释放 */
synchronize_rcu();  /* 可能很慢！ */
```

### 8.3 Grace Period 优化

```c
/* 普通版本 - 可能等待很久 */
synchronize_rcu();

/* 快速版本 - 立即触发 */
synchronize_rcu_expedited();

/* 多次更新 - 批量处理 */
for (i = 0; i < n; i++) {
    spin_lock(&lock);
    list_del_rcu(&entries[i]->list);
    spin_unlock(&lock);
    call_rcu(&entries[i]->rcu, free_func);
}
/* 一次等待所有回调完成 */
rcu_barrier();
```

---

## 九、注意事项

1. **读者不能睡眠**
   ```c
   rcu_read_lock();
   msleep(100);  /* 错误！不能睡眠 */
   rcu_read_unlock();
   ```

2. **必须使用 RCU 变体函数**
   ```c
   /* 错误 */
   list_for_each_entry(pos, &head, list) { }

   /* 正确 */
   list_for_each_entry_rcu(pos, &head, list) { }
   ```

3. **指针访问需要 rcu_dereference**
   ```c
   /* 错误 */
   ptr = global_ptr;
   printk("%d\n", ptr->value);

   /* 正确 */
   rcu_read_lock();
   ptr = rcu_dereference(global_ptr);
   if (ptr)
       printk("%d\n", ptr->value);
   rcu_read_unlock();
   ```

4. **写者必须加锁**
   ```c
   /* 错误 */
   list_add_rcu(&new->list, &head);

   /* 正确 */
   spin_lock(&lock);
   list_add_rcu(&new->list, &head);
   spin_unlock(&lock);
   ```

---

## 十、参考资料

- `include/linux/rcupdate.h` - RCU 核心 API
- `include/linux/rculist.h` - RCU 链表 API
- `include/linux/srcu.h` - SRCU API
- [RCU API](https://www.kernel.org/doc/html/latest/core-api/rcu.html)
- [What is RCU?](https://www.kernel.org/doc/html/latest/RCU/whatisRCU.html)
- [RCU usage](https://www.kernel.org/doc/html/latest/RCU/checklist.html)
