# 链表 (list_head / hlist)

## 概述

Linux 内核中的链表是**侵入式（invasive）**设计的，即链表节点嵌入在数据结构内部，
而不是数据结构包含链表节点。这种设计使得一个数据结构可以同时存在于多个链表中。

## list_head - 双向循环链表

### 数据结构

```c
struct list_head {
    struct list_head *next, *prev;
};
```

### 结构示意

```
    ┌─────────────────────────────────────┐
    │          双向循环链表               │
    └─────────────────────────────────────┘

    head ─────┐
              │
              ▼
    ┌─────────────────────┐
    │ node1               │
    │ next ────────┐      │
    │ prev ──┐     │      │
    └─────────┼─────┼─────┘
              │     │
    ┌─────────┼─────┼────────────┐
    │         │     │            │
    ▼         ▼     ▼            ▼
    ┌─────────────┐ ┌─────────────┐
    │ node2       │ │ node3       │
    │ next        │ │ next        │
    │ prev        │ │ prev        │
    └─────────────┘ └─────────────┘
```

### 定义和初始化

```c
#include <linux/list.h>

// 静态定义并初始化链表头
LIST_HEAD(my_list);

// 或者动态声明并初始化
struct list_head my_list;
INIT_LIST_HEAD(&my_list);
```

### 定义包含链表节点的数据结构

```c
struct my_struct {
    int data;
    struct list_head list;  // 链表节点嵌入在结构中
};
```

### 基本操作

#### 添加节点

```c
struct my_struct *obj = kmalloc(sizeof(*obj), GFP_KERNEL);
obj->data = 42;

// 添加到链表头部
list_add(&obj->list, &my_list);

// 添加到链表尾部
list_add_tail(&obj->list, &my_list);
```

#### 删除节点

```c
list_del(&obj->list);        // 删除但不释放内存
list_del_init(&obj->list);   // 删除并重新初始化节点

// 删除并释放内存
kfree(obj);
```

#### 移动节点

```c
// 移动到另一个链表的头部
list_move(&obj->list, &another_list);

// 移动到尾部
list_move_tail(&obj->list, &another_list);
```

#### 替换节点

```c
struct list_head new_node;
list_replace(&old_node, &new_node);
list_replace_init(&old_node, &new_node);  // 替换并初始化旧节点
```

### 遍历链表

```c
struct my_struct *pos;

// 遍历链表（不安全，删除节点时不要用）
list_for_each_entry(pos, &my_list, list) {
    printk("data = %d\n", pos->data);
}

// 安全遍历（支持删除节点）
list_for_each_entry_safe(pos, tmp, &my_list, list) {
    if (pos->data == 42) {
        list_del(&pos->list);
        kfree(pos);
    }
}

// 反向遍历
list_for_each_entry_reverse(pos, &my_list, list) {
    printk("data = %d\n", pos->data);
}
```

### 其他操作

```c
// 检查链表是否为空
bool empty = list_empty(&my_list);

// 检查是否是链表的最后一个节点
bool is_last = list_is_last(&obj->list, &my_list);

// 检查链表是否只有一个节点
bool single = list_is_singular(&my_list);

// 切割链表：将列表从 entry 处切分，一部分保留在原列表，一部分移到新列表
list_cut_position(&new_list, &my_list, &entry);

// 拼接链表：将一个列表添加到另一个列表的头部
list_splice(&list1, &list2);
list_splice_init(&list1, &list2);  // 拼接后重新初始化 list1
list_splice_tail(&list1, &list2);  // 拼接到尾部
```

### 内核使用示例

```c
// 进程链表遍历
struct task_struct *task;
struct task_struct *me = current;

// 遍历所有进程
for_each_process(task) {
    printk("PID: %d, comm: %s\n", task->pid, task->comm);
}

// 设备模型中的设备链表
struct device *dev;
struct device *my_dev = &some_dev;

list_for_each_entry(dev, &my_dev->p->klist_children, knode_parent) {
    printk("device: %s\n", dev_name(dev));
}
```

---

## hlist_head / hlist_node - 哈希表链表

### 为什么需要 hlist？

`list_head` 是双向循环链表，每个节点需要两个指针（next + prev），对于哈希表的桶
来说会浪费内存。`hlist` 是**双向非循环链表**：
- 表头只需要一个指针
- 节点有两个指针（pprev 指向前一个节点的 next 指针的地址）

### 数据结构

```c
struct hlist_head {
    struct hlist_node *first;
};

struct hlist_node {
    struct hlist_node *next, **pprev;
};
```

### 结构示意

```
    ┌─────────────────────────────────────┐
    │          hlist（哈希表桶）          │
    └─────────────────────────────────────┘

    hash_table[index]
         │
         ▼
    ┌─────────────────┐
    │ hlist_head      │
    │ first ────────┐ │
    └───────────────┼─┘
                    │
                    ▼
    ┌───────────────────────────────┐
    │ hlist_node1                   │
    │ next ───────────────────┐     │
    │ pprev ──(指向head.first)│     │
    └──────────────────────────┼────┘
                               │
                               ▼
                      ┌─────────────────────┐
                      │ hlist_node2         │
                      │ next                │
                      │ pprev ──(指向node1) │
                      └─────────────────────┘
```

### 定义和初始化

```c
#include <linux/list.h>

// 定义哈希表
#define HASH_BITS  4
#define HASH_SIZE  (1 << HASH_BITS)

struct hlist_head my_hash[HASH_SIZE];

// 初始化哈希表
for (i = 0; i < HASH_SIZE; i++) {
    INIT_HLIST_HEAD(&my_hash[i]);
}

// 或者静态初始化
DEFINE_HLIST_HEAD(my_hash_head);
```

### 定义包含 hlist_node 的数据结构

```c
struct my_hash_node {
    int key;
    int value;
    struct hlist_node node;  // 哈希表节点
};
```

### 基本操作

```c
// 计算哈希值
unsigned int hash_val = key & (HASH_SIZE - 1);

// 在哈希表头部添加节点
hlist_add_head(&obj->node, &my_hash[hash_val]);

// 在指定节点之前添加
hlist_add_before(&new_node->node, &old_node->node);

// 在指定节点之后添加
hlist_add_after(&old_node->node, &new_node->node);

// 删除节点
hlist_del(&obj->node);
hlist_del_init(&obj->node);  // 删除并重新初始化
```

### 遍历 hlist

```c
struct my_hash_node *pos;
struct my_hash_node *tmp;
int i;

// 遍历整个哈希表的所有桶
for (i = 0; i < HASH_SIZE; i++) {
    hlist_for_each_entry(pos, &my_hash[i], node) {
        printk("key=%d, value=%d\n", pos->key, pos->value);
    }
}

// 安全遍历（支持删除）
for (i = 0; i < HASH_SIZE; i++) {
    hlist_for_each_entry_safe(pos, tmp, &my_hash[i], node) {
        if (pos->key == target) {
            hlist_del(&pos->node);
            kfree(pos);
        }
    }
}
```

### list_head vs hlist_node

| 特性       | list_head  | hlist_node             |
|------------|------------|------------------------|
| 链表类型   | 双向循环   | 双向非循环             |
| 头节点大小 | 2 个指针   | 1 个指针               |
| 适用场景   | 通用链表   | 哈希表桶               |
| 内存开销   | 稍大       | 更小                   |
| pprev 含义 | 指向前节点 | 指向前节点的 next 指针 |

---

## plist_head - 优先级链表

内核还提供了优先级链表（plist），用于进程调度等场景。

```c
struct plist_head {
    struct list_head node_list;
};

struct plist_node {
    int prio;
    struct list_head prio_list;
    struct list_head node_list;
};
```

```c
// 初始化
PLIST_HEAD(plist_head);

// 添加（按优先级排序）
plist_add(&node->plist_node, &plist_head);

// 删除
plist_del(&node->plist_node);

// 遍历
struct plist_node *node;
plist_for_each(node, &plist_head) {
    printk("prio = %d\n", node->prio);
}
```

---

## 参考资料

- `include/linux/list.h` - 链表 API 定义
- `include/linux/plist.h` - 优先级链表
- [Kernel.org: Linked Lists](https://www.kernel.org/doc/html/latest/core-api/kernel-api.html#linked-lists)
- [Linux Kernel Linked List Explained](https://isis.poly.edu/kulesh/stuff/src/klist/)
