# IDR (Integer ID to Pointer)

## 一、什么是 IDR

IDR (ID Allocation) 是 Linux 内核用于**整数 ID 到指针映射**的数据结构，底层基于
Radix Tree 实现。它主要用于分配和管理整数 ID，并将 ID 与指针关联。

### 为什么需要 IDR？

```
问题：需要动态分配唯一整数 ID，并快速查找对应的指针

传统方案：
    static array[MAX_SIZE];
    线性扫描查找 ID → O(n) 效率低
    预分配大数组 → 浪费内存

IDR 方案：
    动态分配 ID → O(log n) 高效
    内存按需分配 → 节省内存
```

---

## 二、数据结构

```c
#include <linux/idr.h>

struct idr {
    struct radix_tree_root  idr_rt;     /* 底层 radix tree */
    unsigned int            idr_next;   /* 下一个候选 ID */
};

struct ida {
    struct xarray xa;
};
```

**IDR vs IDA:**
- `idr` - ID 关联指针（ID → pointer）
- `ida` - 仅分配 ID，不关联指针

---

## 三、IDR 基本操作

### 3.1 初始化

```c
#include <linux/idr.h>

struct idr my_idr;

/* 动态初始化 */
idr_init(&my_idr);

/* 静态初始化 (DEFINE_IDR 已废弃) */
// DEFINE_IDR(my_idr);  /* 旧方法，不推荐 */
```

### 3.2 分配 ID 并关联指针

```c
/* 分配新 ID，最小从 start 开始 */
int id = idr_alloc(&my_idr, ptr, start, end, gfp_mask);

/* 示例 */
struct my_struct *obj = kmalloc(sizeof(*obj), GFP_KERNEL);
int id = idr_alloc(&my_idr, obj, 0, 0, GFP_KERNEL);
if (id < 0) {
    /* 分配失败 */
    kfree(obj);
    return id;
}

/* 预加载 (避免在持有锁时分配内存) */
idr_preload(gfp_mask);
spin_lock(&lock);
id = idr_alloc(&my_idr, ptr, start, end, GFP_ATOMIC);
spin_unlock(&lock);
idr_preload_end();
```

### 3.3 查找 ID 对应的指针

```c
/* 通过 ID 获取指针 */
void *ptr = idr_find(&my_idr, id);
if (!ptr) {
    /* ID 不存在 */
    return -EINVAL;
}

/* 获取并移除 (不释放指针) */
void *ptr = idr_remove(&my_idr, id);
```

### 3.4 替换指针

```c
/* 替换 ID 关联的指针，返回旧指针 */
void *old = idr_replace(&my_idr, new_ptr, id);
if (IS_ERR(old)) {
    /* ID 不存在 */
    return PTR_ERR(old);
}
```

### 3.5 释放 ID

```c
/* 移除 ID，不释放指针本身 */
void *ptr = idr_remove(&my_idr, id);
if (ptr) {
    kfree(ptr);  /* 手动释放 */
}

/* 释放所有 ID (不释放指针) */
idr_destroy(&my_idr);
```

---

## 四、IDR 遍历

```c
/* 通过 ID 遍历 */
int id;
void *ptr;

idr_for_each_entry(&my_idr, ptr, id) {
    printk("ID %d -> %p\n", id, ptr);
}

/* 从指定 ID 开始遍历 */
idr_for_each_entry_from(&my_idr, ptr, id, start) {
    printk("ID %d -> %p\n", id, ptr);
}

/* 获取下一个 ID */
int next_id = idr_get_next(&my_idr, &id);

/* 获取上一个 ID */
int prev_id = idr_get_prev(&my_idr, &id);
```

---

## 五、IDA (ID Allocator)

IDA 只分配 ID，不关联指针。

### 5.1 初始化

```c
struct ida my_ida;

ida_init(&my_ida);

/* 定义并初始化 */
DEFINE_IDA(my_ida);
```

### 5.2 分配和释放 ID

```c
/* 分配 ID */
int id = ida_alloc_min(&my_ida, min, GFP_KERNEL);
int id = ida_alloc_max(&my_ida, max, GFP_KERNEL);
int id = ida_alloc_range(&my_ida, min, max, GFP_KERNEL);
int id = ida_alloc(&my_ida, GFP_KERNEL);  /* 从 0 开始 */

/* 释放 ID */
ida_free(&my_ida, id);

/* 检查 ID 是否空闲 */
bool ida_is_empty(&my_ida);
```

### 5.3 销毁

```c
/* 释放所有资源 */
ida_destroy(&my_ida);
```

---

## 六、内核应用示例

### 6.1 PID 分配 (进程 ID)

```c
/* kernel/pid.c */

struct pid_namespace {
    struct idr idr;
    // ...
};

/* 分配 PID */
struct pid *alloc_pid(struct pid_namespace *ns)
{
    struct pid *pid;
    int nr;

    pid = kmem_cache_zalloc(pid_cachep, GFP_KERNEL);
    if (!pid)
        return NULL;

    /* 分配 PID 号 */
    nr = idr_alloc(&ns->idr, pid, 1, 0, GFP_KERNEL);
    if (nr < 0) {
        kmem_cache_free(pid_cachep, pid);
        return NULL;
    }

    pid->numbers[0].nr = nr;
    return pid;
}

/* 查找 PID */
struct pid *find_pid_ns(int nr, struct pid_namespace *ns)
{
    return idr_find(&ns->idr, nr);
}

/* 释放 PID */
void free_pid(struct pid *pid)
{
    /* 从 idr 移除 */
    idr_remove(&pid->numbers[0].ns->idr, pid->numbers[0].nr);

    kmem_cache_free(pid_cachep, pid);
}
```

### 6.2 设备 ID 管理

```c
/* 设备号分配 (字符设备) */

static DEFINE_IDA(chrdevs_ida);

/* 分配设备号 */
int __register_chrdev(unsigned int major, unsigned int baseminor,
                      unsigned int count, const char *name,
                      const struct file_operations *fops)
{
    int ret;

    if (major == 0) {
        /* 动态分配主设备号 */
        major = ida_alloc_max(&chrdevs_ida, MAX_MAJOR, GFP_KERNEL);
        if (major < 0)
            return major;
    }

    /* ... 注册字符设备 ... */
    return 0;
}

/* 释放设备号 */
void __unregister_chrdev(unsigned int major, unsigned int baseminor,
                         unsigned int count)
{
    /* ... 注销字符设备 ... */

    if (major < MAX_MAJOR)
        ida_free(&chrdevs_ida, major);
}
```

### 6.3 IRQ 编号

```c
/* kernel/irq/irqdesc.c */

static DEFINE_IDA(irq_desc_alloc);

struct irq_desc *irq_to_desc(unsigned int irq)
{
    return radix_tree_lookup(&irq_desc_tree, irq);
}

/* 分配 IRQ 描述符 */
struct irq_desc *alloc_desc(int irq, int node, unsigned int flags,
                            const char *name, struct module *owner)
{
    struct irq_desc *desc;

    /* 分配 ID */
    if (irq < 0) {
        irq = ida_alloc_max(&irq_desc_alloc, irq, GFP_KERNEL);
        if (irq < 0)
            return NULL;
    }

    /* ... 分配并初始化 desc ... */
    return desc;
}
```

---

## 七、XArray 替代 IDR

新内核推荐使用 XArray 代替 IDR。

```c
#include <linux/xarray.h>

/* 初始化 */
struct xarray xa;
xa_init(&xa);
DEFINE_XARRAY(name);

/* 插入条目 */
void *entry = kmalloc(sizeof(*entry), GFP_KERNEL);
int id = xa_alloc(&xa, entry, xa_limit_32b, GFP_KERNEL);

/* 查找条目 */
void *entry = xa_load(&xa, id);

/* 删除条目 */
void *entry = xa_erase(&xa, id);

/* 遍历 */
unsigned long index;
void *entry;
xa_for_each(&xa, index, entry) {
    printk("id=%lu, entry=%p\n", index, entry);
}
```

---

## 八、IDR vs XArray

| 特性 | IDR | XArray |
|------|-----|--------|
| **API** | 旧 API，仍在使用 | 新 API，推荐 |
| **底层** | Radix Tree | XArray (改进的 Radix Tree) |
| **并发** | 需要外部锁 | 内部 RCU |
| **标记** | 不支持 | 支持条目标记 |
| **多态** | 仅指针 | 支持值、指针、条目标记 |

---

## 九、注意事项

1. **IDR 不是线程安全的**
   ```c
   /* 需要外部加锁 */
   spin_lock(&lock);
   id = idr_alloc(&my_idr, ptr, start, end, GFP_ATOMIC);
   spin_unlock(&lock);
   ```

2. **使用 idr_preload 避免死锁**
   ```c
   idr_preload(GFP_KERNEL);
   spin_lock(&lock);
   id = idr_alloc(&my_idr, ptr, start, end, GFP_ATOMIC);
   spin_unlock(&lock);
   idr_preload_end();
   ```

3. **记得释放指针**
   ```c
   /* idr_remove 只移除映射，不释放指针 */
   void *ptr = idr_remove(&my_idr, id);
   kfree(ptr);  /* 手动释放 */
   ```

4. **新项目考虑 XArray**
   ```c
   /* 新代码推荐使用 XArray */
   struct xarray xa;
   xa_init(&xa);
   ```

---

## 十、参考资料

- `include/linux/idr.h` - IDR API
- `include/linux/xarray.h` - XArray API
- `kernel/pid.c` - PID 分配示例
- `fs/char_dev.c` - 字符设备 ID 管理
- [IDR documentation](https://www.kernel.org/doc/html/latest/core-api/idr.html)
- [XArray documentation](https://www.kernel.org/doc/html/latest/core-api/xarray.html)
