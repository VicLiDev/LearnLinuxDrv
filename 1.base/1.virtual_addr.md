# 虚拟内存

## 物理和虚拟寻址

虚拟内存提供了三个重要的能力：
1. 他将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，
   并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理
3. 它保护了每个进程的地址空间不被其他进程破坏


计算机系统的主存被组织成一个由M个连续的字节大小的单元组成的数组。每个字节都有一个
唯一的物理地址(Physical Address, PA)。CPU访问内存最自然的方式就是使用物理地址，
这种方式称为物理寻(physical addressing)。而现代处理器使用的是一种称为虚拟寻址
(virtual addressing)的寻址形式。

```
CPU芯片                                              主存
+-----------------------------+                    +-------+
|                             |                0:  |       |
|      虚拟地址(VA)  地址翻译 | 物理地址(PA)       +-------+
| CPU ------------->   MMU   ----------------> 1:  |       |
|  ^     4100                 |                    +-------+
+--+--------------------------+                2:  |       |
   |                                               +-------+
   |                                           3:  |||||||||   -|
   |                                               +-------+    |
   |                                           4:  |||||||||    |-----+
   |                                               +-------+    |     |
   |                                           5:  |||||||||   -|     |
   |                                               +-------+          |
   |                                                  ...             |
   |                                               +-------+          |
   |                                               |       |          |
   |                                               +-------+          |
   |                                           M-1:|       |          |
   |                                               +-------+          |
   |                                                                  |
   +------------------------------------------------------------------+
```

使用虚拟寻址，CPU通过生成一个虚拟地址（Virtual Address,VA）来访问主存，这个虚拟
地址被送到内存之前先转换成适当的物理地址

## 地址空间

如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间(linear address space)。
为了简化讨论，我们总是假设使用的是线性地址空间。在一个带虚拟内存的系统中。CPU从一个
由N=2^n个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual address
 space)。一个系统还有一个物理地址空间（physical address space），对应于系统中物理
内存的M个字节

## 虚拟内存作为缓存的工具

VM系统将虚拟内存分割为虚拟页(Virtual Page, VP)的大小固定的块。每个虚拟页的大小为
P=2^p字节。类似的，物理被分割为物理页(Physical Page,PP)，大小也是P字节（物理页也被
称为页帧(page frame))。

在任意时刻，虚拟页面的集合都分为三个不相交的子集：
* 未分配的：VM系统还为分配（或者创建）的页。未分配的块没有任何数据和它们相关联，
  因此也就不占用任何磁盘空间。
* 已缓存：当前已缓存在物理内存中的已分配页
* 未缓存：未缓存在物理内存中的已分配页

tips:
* 未分配的意思是没有建立内存和磁盘的映射关系
* 缓存的和未缓存的页都是建立了映射关系的
    * 缓存的意思是建立了内存和磁盘的映射关系，并且从磁盘中缓存了数据
    * 未缓存的意思是建立了内存和磁盘的映射关系，但没从磁盘中缓存数据

SRAM 一般用作高速缓存
DRAM 一般用在内存条（物理内存）

### 页表

每个进程都会有属于自己的页表（Page Table Entry，PTE）

同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在DRAM中的某个
地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须
判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘
复制到DRAM中，替换这个牺牲页。

在物理内存中需要存放一个叫做页表（page table）的数据结构，页表将虚拟页映射到物理
页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责
维护页表的内容，以及在磁盘与DRAM直接来回传送页。

页表就是一个页表条目（Page Table Entry,PTE）的数组。虚拟地址空间中的每个页在页表
中一个固定偏移量处都有一个PTE。为了我们的目的，我们将假设每个PTE是由一个有效位
（valid bit）和一个n位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在DRAM中。
如果设置了有效位，那么地址字段就表示DRAM中相应的物理页的起始位置，这个物理页中
缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，
这个地址就指向该虚拟页在磁盘上的起始位置。
```
            物理页号或                    物理内存
     有效位  磁盘地址                     （DRAM）
      +---------------+   +---------> +---------------+
PTE 0 |0|   null      |   |           |     VP1       | PP0
      +---------------+   | +-------> +---------------+
PTE 1 |1|    *--------+---+ |         |     VP2       |
      +---------------+     |   +---> +---------------+
PTE 2 |1|    *--------+-----+   |     |     VP7       |
      +---------------+       +-----> +---------------+
PTE 3 |0|    *--------------+ | |     |     VP4       | PP3
      +---------------+     | | |     +---------------+
PTE 4 |1|    *--------+-------+ |
      +---------------+     |   |
PTE 5 |0|   null      |     |   |         虚拟内存
      +---------------+     |   |         （磁盘）
PTE 6 |0|    *--------+--+  |   |     +---------------+
      +---------------+  |  |   |     |     VP1       |
PTE 7 |1|    *--------+---------+     +---------------+
      +---------------+  |  |         |     VP2       |
        常驻内存的页表   |  +-------> +---------------+
            (DRAM)       |            |     VP3       |
                         |            +---------------+
                         |            |     VP4       |
                         +----------> +---------------+
                                      |     VP6       |
                                      +---------------+
                                      |     VP7       |
                                      +---------------+
```
* 四个虚拟页（VP1、VP2、VP4和VP7）当前被缓存在DRAM中
* 两个虚拟页（VP0和VP5）还未被分配
* 剩下的页（VP3和VP6）已经被分配，但当前还为被缓存

### 页命中（已缓存）

考虑下当CPU想要读包含在VP2中的虚拟内存的一个字时会发生什么，VP2被缓存在DRAM中。
地址翻译硬件将虚拟地址作为一个索引来定位PTE2，并从内存中读取他。因为设置了有效位，
那么地址翻译硬件就知道VP2是换存在内存中的了。所以它使用PTE中的物理内存地址（该
地址指向PP1中缓存页的起始位置），构造出这个字的物理地址。
```
  虚拟地址                     物理页号或                    物理内存
+---------+             有效位  磁盘地址                     （DRAM）
|         |              +---------------+   +---------> +---------------+
+---------+        PTE 0 |0|   null      |   |           |     VP1       | PP0
     |                   +---------------+   | +-------> +---------------+
     |             PTE 1 |1|    *--------+---+ |         |     VP2       |
     |                   +---------------+     |   +---> +---------------+
     +-----------> PTE 2 |1|    *--------+-----+   |     |     VP7       |
                         +---------------+       +-----> +---------------+
                   PTE 3 |0|    *--------------+ | |     |     VP4       | PP3
                         +---------------+     | | |     +---------------+
                   PTE 4 |1|    *--------+-------+ |
                         +---------------+     |   |
                   PTE 5 |0|   null      |     |   |         虚拟内存
                         +---------------+     |   |         （磁盘）
                   PTE 6 |0|    *--------+--+  |   |     +---------------+
                         +---------------+  |  |   |     |     VP1       |
                   PTE 7 |1|    *--------+---------+     +---------------+
                         +---------------+  |  |         |     VP2       |
                           常驻内存的页表   |  +-------> +---------------+
                               (DRAM)       |            |     VP3       |
                                            |            +---------------+
                                            |            |     VP4       |
                                            +----------> +---------------+
                                                         |     VP6       |
                                                         +---------------+
                                                         |     VP7       |
                                                         +---------------+
```

### 缺页（未缓存）

DRAM缓存不命中成为缺页（page fault）。读VP3中的字时，VP3并未缓存在DRAM中。地址
翻译硬件从内存中读取PTE3，从有效位推断出VP3未被缓存，并且触发一个缺页异常。

缺页异常调用内核中的缺页异常处理程序。该程序会选择一个牺牲页，在此例中就是存放在
PP3中的VP4.如果VP4已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都
会修改VP4的页表条目，反映出VP4不在缓存在内存中这一事实。

```
  虚拟地址                     物理页号或                    物理内存
+---------+             有效位  磁盘地址                     （DRAM）
|         |              +---------------+   +---------> +---------------+
+---------+        PTE 0 |0|   null      |   |           |     VP1       | PP0
     |                   +---------------+   | +-------> +---------------+
     |             PTE 1 |1|    *--------+---+ |         |     VP2       |
     |                   +---------------+     |   +---> +---------------+
     +-----------> PTE 2 |1|    *--------+-----+   |     |     VP7       |
                         +---------------+       +-----> +---------------+
                   PTE 3 |0|    *--------------+ | |     |     VP4       | PP3
                         +---------------+     | | |     +---------------+
                   PTE 4 |1|    *--------+-------+ |
                         +---------------+     |   |
                   PTE 5 |0|   null      |     |   |         虚拟内存
                         +---------------+     |   |         （磁盘）
                   PTE 6 |0|    *--------+--+  |   |     +---------------+
                         +---------------+  |  |   |     |     VP1       |
                   PTE 7 |1|    *--------+---------+     +---------------+
                         +---------------+  |  |         |     VP2       |
                           常驻内存的页表   |  +-------> +---------------+
                               (DRAM)       |            |     VP3       |
                                            |            +---------------+
                                            |            |     VP4       |
                                            +----------> +---------------+
                                                         |     VP6       |
                                                         +---------------+
                                                         |     VP7       |
                                                         +---------------+
```

接下来内核从磁盘复制VP3到内存中的PP3，更新PTE3，随后返回。当异常处理程序返回时，
他会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。
但是现在，VP3已经缓存在了主存中了，那么页命中也能由地址翻译硬件正常处理了。

```
  虚拟地址                     物理页号或                    物理内存
+---------+             有效位  磁盘地址                     （DRAM）
|         |              +---------------+   +---------> +---------------+
+---------+        PTE 0 |0|   null      |   |           |     VP1       | PP0
     |                   +---------------+   | +-------> +---------------+
     |             PTE 1 |1|    *--------+---+ |         |     VP2       |
     |                   +---------------+     |   +---> +---------------+
     +-----------> PTE 2 |1|    *--------+-----+   |     |     VP7       |
                         +---------------+       +-----> +---------------+
                   PTE 3 |0|    *----------------+ |     |     VP3       | PP3
                         +---------------+         |     +---------------+
                   PTE 4 |1|    *--------+-----+   |
                         +---------------+     |   |
                   PTE 5 |0|   null      |     |   |         虚拟内存
                         +---------------+     |   |         （磁盘）
                   PTE 6 |0|    *--------+--+  |   |     +---------------+
                         +---------------+  |  |   |     |     VP1       |
                   PTE 7 |1|    *--------+---------+     +---------------+
                         +---------------+  |  |         |     VP2       |
                           常驻内存的页表   |  |         +---------------+
                               (DRAM)       |  |         |     VP3       |
                                            |  +-------> +---------------+
                                            |            |     VP4       |
                                            +----------> +---------------+
                                                         |     VP6       |
                                                         +---------------+
                                                         |     VP7       |
                                                         +---------------+
```

总结上述过程：
1. 触发缺页异常
2. 缓存回写（释放）
3. 缓存使用（重映射）（使用）

虚拟内存的习惯说法中，块被称为页。在磁盘和内存之间传送页的活动叫做交换（swapping）
或者页面调度（paging）。页从磁盘换入（或者页面调入）DRAM和从DRAM换出（或者页面调出）
磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需
页面调度（demand paging）。所有现代系统都是用的是按需页面调度的方式。


## 虚拟内存作为内存管理的工具

VM为进程提供独立的地址空间。操作系统为系统中的每个进程都维护一个独立的页表，
多个虚拟页面可以映射到同一个共享物理页面上。
```
              虚拟地址空间                       物理内存
       0   +---------------+              0 +---------------+
           |               |                |               |
           +---------------+    地址翻译    +---------------+
进程i:     |     VP1       |--------------->|     PP2       |
           +---------------+                +---------------+
           |     VP2       |------+         |               |
           +---------------+      |         +---------------+
           |               |      |         |               |
       N-1 +---------------+      |         +---------------+
                                  |         |               |
                                  |         +---------------+
                                  |         |               |
       0   +---------------+      |         +---------------+
           |               |      +-------->|     PP7       | 共享页面
           +---------------+      |         +---------------+
进程j:     |     VP1       |------+         |               |
           +---------------+                +---------------+
           |     VP2       |--------------->|     pp10      |
           +---------------+                +---------------+
           |               |                |               |
       N-1 +---------------+            M-1 +---------------+
```

VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配。
* 简化链接：独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和
  数据实际存放在物理内存的何处。对于64位地址空间，代码段总是从虚拟地址0x400000开
  始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间
  最高的部分，并向下生长
* 简化加载：虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件
  中.text和.data节加载到一个新创建的进程中，Linux加载起为代码和数据段分配虚拟页，
  把他们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。但加载
  器不从磁盘到内存实际复制任何数据。在每个页初次被引用时，要么是CPU取指令时引用
  的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要
  自动的调入数据页。

将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法乘坐内存映射(memory mapping)。
Linux提供一个称为mmap的系统调用，允许应用程序自己做内存映射。

## 虚拟内存作为内存保护的工具

任何现代计算机系统必须为操作系统提供手段来控制对内存系统的访问。如果一条指令违反了
访问的约定，那么CPU就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。
Linux shell一般将这种异常报告位“段错误（segmentation fault）”

## 地址翻译

```
                                      虚拟地址
+----------+           n-1              p  p-1               0
| 页表基址 |           +-----------------+-------------------+
|  寄存器  |      -----+ 虚拟页号(VPN)   | 虚拟页偏移量(VPO) |
|  (PTBR)  |      |    +-----------------+----------------*--+
+----+-----+      |                                       |
     |            |                                       |
     |            |                                       |
     |            |    有效位   物理页号(PPN)             |
     +---------------> +-------------------------+        |
                  |    |    |                    |        |
                  |    +-------------------------+        |
                  +--> | *  |           *        |  页表  |
               VPN作为 +-|--------------|--------+        |
               到页表中| |  |           |        |        |
               的索引  +-|--------------|--------+        |
                       | |  |           |        |        |
                       +-|--------------|--------+        |
                         |              |                 |
                         |              |                 |
     如果有效位=0，      |              |                 |
     那么页面就不在 <----+              |                 |
     存储器中（缺页）          m-1      V      p  p-1     V         0
                              +-------------------------------------+
                              | 物理页号(PPN)   | 物理页偏移量(PPO) |
                              +-------------------------------------+
                                           物理地址
```

CPU中的一个控制寄存器，页表基址寄存器（Page Table Base Register，PTBR）指向当前
页表。每个进程都有自己的页表，切换到当前进程后，会以当前进程的页表基址更新PTBR，
对于Linux是 current->mm.pgd(task_struct)。

n位的虚拟地址包含两个部分：一个p位的虚拟页面偏移（Virtual Page Offset，VPO）和
一个（n-p）位的虚拟页号（Virtual Page Number，VPN）。MMU利用VPN来选择适当的PTE。
例如，VPN 0 选择PTE 0，VPN 1选择PTE 1，以此类推。将页表条目中物理页号（Physical
Page Number，PPN）和虚拟地址中的VPO串联起来，就得到相应的物理地址。

注意，因为物理和虚拟页面都是P字节的，所以物理页面偏移（Physical Page Offset，PPO）
和VPO是相同的。

```
CPU芯片
+---------------------------+   2       +---------+
|                  +-----+  |  PTEA     |         |
|                  |     |------------> |         |
| +--------+   1   |     |<------------ | 高速缓  |
| | 处理器 |------>| MMU |  |   PTE     | 存/内存 |
| +--------+  VA   |     |  |    3      |         |
|    ^             |     |  |   PA      |         |
|    |             |     |------------> |         |
|    |             +-----+  |   4       |         |
|    |                      |           |         |
+----|----------------------+           |         |
     +--------------------------------- |         |
               数据                     +---------+
                5
```
上图展示了当页面命中时，CPU硬件执行的步骤：
1. 处理器生成了一个虚拟地址，并把它传送给MMU
2. MMU生成PTE地址，并从高速缓存/主存请求得到它
3. 告诉缓存/主存向MMU返回PTE
4. MMU构造物理地址，并把它传送给告诉缓存/主存
5. 高速缓存/主存返回所有请求的数据字给处理器


```
                                  4
                                 异常          +------------------+
                      +----------------------->| 缺页异常处理程序 |
                      |                        +------------------+
CPU芯片               |                                    |
+---------------------|-----+   2       +---------+        V       +---------+
|                  +-----+  |  PTEA     |         |  牺牲页 (保存) |         |
|                  |     |------------> |         |--------------->|         |
| +--------+   1   |     |<------------ | 高速缓  |    5    (换出) |  磁盘   |
| | 处理器 |------>| MMU |  |   PTE     | 存/内存 |                |         |
| +--------+  VA   |     |  |    3      |         |  新页 (读入)   |         |
|             7    |     |  |           |         |<---------------|         |
|                  |     |  |           |         |    6  (换入)   |         |
|                  +-----+  |           |         |                |         |
+---------------------------+           +---------+                +---------+
```
上图展示了缺页时的处理过程，处理缺页要求硬件和操作系统内核协作完成：
1. 1-3步与命中时相同
4. PTE中的有效位是0，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页
   异常处理程序。
5. 缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到
   磁盘。
6. 缺页处理程序调入新的页面，并更新内存中的PTE。
7. 缺页处理程序返回到原来的进程，在此执行导致系统缺页的指令。CPU将引起缺页的虚拟
   地址重新发送给MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，在MMU执行了
   正常命中的步骤之后，主存就会将所请求的字返回给处理器。

### 结合高速缓存和虚拟内存

在任何既使用虚拟内存又使用SRAM高速缓存的系统中，都有应该是用虚拟地址还是使用物理
地址来访问SRAM高速缓存的问题。大多数系统是选择物理寻址的。使用物理寻址，多个进程
同时在高速缓存中有存储块和共享来自相同虚拟页面的块成为很简单的事情。而且，高速缓
存无需处理保护问题，因为访问权限的检查是地址翻译过程的一部分。

下图展示了一个物理寻址的高速缓存如何和虚拟内存结合起来。主要的思路是地址翻译发生
在高速缓存查找之前。注意，页表条目可以缓存，就像其他的数据字一样。
```
CPU芯片
+---------------------------+           +---------+       +--------+
|                  +-----+  |   PTE     |PTEA     |  PTE  |        |
|                  |     |<------------ |命中     |<------|        |
| +--------+       |     |  |           |         |       |        |
| | 处理器 |------>| MMU |  |   PTEA    |    PTEA | PTEA  |        |
| +--------+  VA   |     |------------> |   不命中|------>|        |
     ^             |     |  |           |         |       |        |
|    |             |     |  |   PA      |      PA |  PA   |  内存  |
|    |             |     |------------> |   不命中|------>|        |
|    |             +-----+  |           |         |       |        |
|    |                      |           |         |       |        |
+----|----------------------+           |PA       |  数据 |        |
     +--------------------------------- |命中     |<------|        |
               数据                     +---------+       +--------+
                                            L1
                                          高速缓存
```

### 利用TLB加速地址翻译

每次CPU产生一个虚拟地址，MMU都必须查阅一个PTE，为了消除这个代价，在MMU中包括了一个
PTE的小的缓存，称为翻译后备缓冲器（Translation Lookaside Buffer，TLB）。

TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有
高度的关联度。如下图所示：
```
n-1             p+t  p+t-1            p   p-1          0
+------------------+--------------------+--------------+
| TLB标记   (TLBT) | TLB索引     (TLBI) |     VPO      |
+------------------+--------------------+--------------+

<-------------- VPN ------------------->
```
用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果TLB中
有T=2^t个组，那么TLB索引（TLBI）是由VPN的t个最低位组成的，而TLB标记（TLBT）是由VPN
中剩余的位组成的

简单理解，将TLB的buffer分2^t组，那这t组就需要t个bit来进行索引，这个分组相当于把TLB
分成大块，然后每一块中的条目，再用TLBT进行索引

下图展示了当TLB命中时（通常情况）所包括的步骤。这里的关键点是，所有的地址翻译步骤
都是在芯片上的MMU中执行的，因此非常快
* 第一步： CPU产生一个虚拟地址
* 第二步和第三步：MMU从TLB中取出相应的PTE
* 第四步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。
* 第五步：高速缓存/主存将所有请求的数据字返回给CPU
```
CPU芯片
+-----------------------------+
|                +------+     |
|                | TLB  |     |
|                +------+     |
|                  ^  |       |
|             2 VPN|  |PTE 3  |
|                  |  v       |
|                +------+     |      +---------+
|                |      |     |      |         |
|                |      |     |      |         |
| +--------+  1  |      |     |  4   | 高速缓  |
| | 处理器 |---->| 翻译 |----------->| 存/主存 |
| +--------+ VA  |      |     | PA   |         |
|     ^          |      |     |      |         |
|     |          +------+     |      +---------+
|     |                       |           |
+-----|-----------------------+           |
      |                                   |
      +-----------------------------------+
                   5 数据
```

当PTE不命中时，MMU必须从L1换存中取出相应的PTE，如下图所示，新取出的PTE存放在TLB中，
可能会覆盖一个已经存在的条目。
```
CPU芯片
+-----------------------------+  4
|                +------+     | PTE
|                | TLB  | <--------+
|                +------+     |    |
|                  ^  ^       |    |
|             2 VPN|  |       |    |
|                  |  v       |    |
|                +------+     |    |   +---------+
|                |      |     |    +---|         |
|                |      |     |   3    |         |
|                |      |------------->|         |
|                |      |     | PTEA   |         |
| +--------+  1  |      |     |  5     | 高速缓  |
| | 处理器 |---->| 翻译 |------------->| 存/主存 |
| +--------+ VA  |      |     | PA     |         |
|     ^          |      |     |        |         |
|     |          +------+     |        +---------+
|     |                       |             |
+-----|-----------------------+             |
      |                                     |
      +-------------------------------------+
                   6 数据
```

### 多级页表

用来压缩页表的常用方法是使用层次结构的页表。减少内存占用的逻辑如下：
1. 如果一级页表中的一个PTE是空的，那么相应的二级页表根本就不存在，可以节省空间
2. 只有一级页表才需要总是在主存中，虚拟内存系统可以在需要时创建、页面调入或调出
   二级页表，这就减少了主存的压力，只有最经常使用的二级页表才需要缓存在主存中

下图描述了使用k级页表层次结构的地址翻译。虚拟地址被划分为k个VPN和1个VPO。每个VPN i
都是一个到第i级页表的索引，其中 1 <= i <= k。第j级页表中的每个PTE，1 <= j <= k-1，
都指向第j+1级的某个页表的基址。第k级页表中的每个PTE包含某个物理页面的PPN，或者一个
磁盘块的地址。为了构造物理地址，在能够确定PPN之前，MMU必须访问k个PTE。和只有一级
到页表结构一样，PPO和VPO是相同的。
```
                 虚拟地址
n-1                                              p-1  0  bit
+-------------+-------------+-----+-------------+-----+
| * VPN 1     | * VPN 2     | ... | * VPN k     | VPO |
+-|-----------+-|-----------+-----+-|-----------+-----+
  |             |                   |           |<--->|
  |             |                   |              |
  |  1级页表    |  2级页表          |  k级页表     |
  |  +----+  +---->+----+  +->... ---->+----+      |
  |  |    |  |  |  |    |  |        |  |    |      |
  |  +----+  |  |  +----+  |        |  +----+      |
  +->|\\\\|--+  |  |    |  |        |  |    |      |
     +----+     |  +----+  |        |  +----+      |
     |    |     +->|\\\\|--+        |  |    |      |
     +----+        +----+           |  +----+      |
     |    |        |    |           +->|PPN |--+   |
     +----+        +----+              +----+  |   |
     |    |        |    |              |    |  |   |
     +----+        +----+              +----+  |   |
                                   +-----------+   |
                                   |               |
                  m-1              V           p-1 V  0
                  +-----------------------------------+
                  |              PPN            | PPO |
                  +-----------------------------------+
                                物理地址
```
