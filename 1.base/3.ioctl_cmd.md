# Linux内核中IO/IOR/IOW/IOWR宏的用法与解析

---

## 1. 基础背景

在 Linux 中，`ioctl` 的调用形式是：
```c
int ioctl(int fd, unsigned long cmd, ...);
```
* `fd`：文件描述符（设备文件的句柄）
* `cmd`：命令号（由 `IO`, `IOR`, `IOW`, `IOWR` 宏生成）
* `arg`：指针或参数，通常是用户态传给内核的数据，或者内核写回给用户态的数据

**重点：** `cmd` 不仅仅是一个数字，而是由 **方向、类型、序号、大小** 等信息组合而成的编码。

---

## 2. 宏的定义

源代码位置：
```
include/uapi/asm-generic/ioctl.h
arch/alpha/include/uapi/asm/ioctl.h
arch/sparc/include/uapi/asm/ioctl.h
```

以 `arch/alpha/include/uapi/asm/ioctl.h` 为例，实现如下：
```
#define _IOC_NRBITS	8
#define _IOC_TYPEBITS	8
#define _IOC_SIZEBITS	13
#define _IOC_DIRBITS	3

#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)

#define _IOC_NRSHIFT	0
#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)

/*
 * Direction bits _IOC_NONE could be 0, but OSF/1 gives it a bit.
 * And this turns out useful to catch old ioctl numbers in header
 * files for us.
 */
#define _IOC_NONE	1U
#define _IOC_READ	2U
#define _IOC_WRITE	4U

#define _IOC(dir,type,nr,size)			\
	((unsigned int)				\
	 (((dir)  << _IOC_DIRSHIFT) |		\
	  ((type) << _IOC_TYPESHIFT) |		\
	  ((nr)   << _IOC_NRSHIFT) |		\
	  ((size) << _IOC_SIZESHIFT)))

/* used to create numbers */
#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
```

这些宏主要用于 **设备驱动程序** 中定义 **ioctl 命令码**（即 `cmd`），供用户态
`ioctl(fd, cmd, arg)` 调用时和内核进行交互。

cmd的大小为 32位，共分 4 个域:
* bit00-bit07: nr: 命令序号（8 位）
* bit08-bit15: type: 设备类型/幻数/魔数（8 位）
* bit16-bit28: size: 参数数据结构大小（13 位，最多 8191 字节）
* bit29-bit31: dir: 方向（3 位，可组合 READ/WRITE/NONE）

**命令序号/基(序列号)数**
基数用于区别各种命令。通常，从 *0*开始递增，相同设备驱动程序上可以重复使用该值。
例如，读取和写入命令中使用了相同的基数，设备驱动程序也能分辨出来，原因在于设备
驱动程序区分命令时使用 switch ，且直接使用命令变量 cmd 值。创建命令的宏生成的值
由多个域组合而成，所以即使是相同的基数，也会判断为不同的命令。设备驱动程序想要
从命令中获取该基数，就使用下面的宏：
`_IOC_NR (cmd)`

**魔数 (magic number)**
魔数范围为 0~255 。通常，用英文字符 "A" ~ "Z" 或者 "a" ~ "z" 来表示。设备驱动程序
从传递进来的命令获取魔数，然后与自身处理的魔数相比较，如果相同则处理，不同则不处理。
魔数是拒绝误使用的初步辅助状态。设备驱动程序可以通过 **_IOC_TYPE** (cmd) 来获取
魔数。不同的设备驱动程序最好设置不同的魔数，但并不是要求绝对，也是可以使用其他
设备驱动程序已用过的魔数。

**变量类型**
设备驱动程序想要从传送的命令获取相应的值，就要使用宏函数：`_IOC_SIZE(cmd)`

**方向**
例如命令码中的 “区分读写区” 里的值可能是 _ IOC_NONE （0值）表示无数据传输，
_ IOC_READ (读)， _ IOC_WRITE (写) ， _ IOC_READ|_IOC_WRITE (双向)。

---

## 3. 四个宏的含义

1. **`_IO(type, nr)`**
   * 无数据传输，仅仅是命令控制
   * 常用于简单的控制命令，比如复位设备、启动/停止等

2. **`_IOR(type, nr, data_type)`**
   * **I/O Read**：从内核读数据到用户空间
   * 用户空间传入指针，内核将结果写回

   例子：获取设备状态

3. **`_IOW(type, nr, data_type)`**
   * **I/O Write**：从用户空间写数据到内核
   * 用户传入的数据结构由内核读取

   例子：设置设备参数

4. **`_IOWR(type, nr, data_type)`**
   * **I/O Read & Write**：双向传输，用户传入数据结构，内核也可能修改并返回
   * 常用于需要参数和返回值同时存在的场景

---

## 4. 参数说明及使用方法

* `type`：设备的“幻数”，通常是一个 **字符常量**（如 `'M'`，`'T'`），用于区分不同驱动
* `nr`：命令编号（同一个 `type` 下不同操作的编号）
* `data_type`：数据结构类型，宏内部会取 `sizeof(data_type)`

这样保证了用户态和内核态的数据结构大小一致

**关键记住使用方法**

创建命令（内部调用的都是宏 _IOC(dir,type,nr,size)）：
```c
_IO(type,nr)
_IOR(type,nr,size)
_IOW(type,nr,size)
_IOWR(type,nr,size)
```

获取域值：
```c
_IOC_TYPE(cmd)  // 魔数 type
_IOC_NR(cmd)    // 区别序号 nr
_IOC_SIZE(cmd)  // 数据大小 size
_IOC_DIR(cmd)   // 数据方向 read/write
```

---

## 5. 示例

假设我们写一个 LED 灯驱动，提供三个功能：

* 打开灯（无参数）
* 设置亮度（写参数）
* 获取状态（读参数）
* 同时设置并返回状态（读写参数）

定义 ioctl 命令码：
```c
#define LED_MAGIC   'L'

#define LED_ON      _IO(LED_MAGIC, 0)                  // 无参数
#define LED_SET     _IOW(LED_MAGIC, 1, int)            // 写参数：亮度
#define LED_GET     _IOR(LED_MAGIC, 2, int)            // 读参数：状态
#define LED_CONFIG  _IOWR(LED_MAGIC, 3, struct led_cfg) // 读写参数
```

在驱动的 `unlocked_ioctl` 中处理：

```c
long led_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    int value;
    struct led_cfg cfg;

    switch (cmd) {
    case LED_ON:
        led_turn_on();
        break;

    case LED_SET:
        if (copy_from_user(&value, (int __user *)arg, sizeof(value)))
            return -EFAULT;
        led_set_brightness(value);
        break;

    case LED_GET:
        value = led_get_status();
        if (copy_to_user((int __user *)arg, &value, sizeof(value)))
            return -EFAULT;
        break;

    case LED_CONFIG:
        if (copy_from_user(&cfg, (struct led_cfg __user *)arg, sizeof(cfg)))
            return -EFAULT;
        led_apply_config(&cfg);
        cfg.result = 0; // 回填结果
        if (copy_to_user((struct led_cfg __user *)arg, &cfg, sizeof(cfg)))
            return -EFAULT;
        break;

    default:
        return -ENOTTY;
    }
    return 0;
}
```

---

## 6. 用户态调用示例

```c
int fd = open("/dev/led", O_RDWR);
int brightness = 80;
int status;

ioctl(fd, LED_ON);                             // 打开灯
ioctl(fd, LED_SET, &brightness);               // 设置亮度
ioctl(fd, LED_GET, &status);                   // 获取状态
struct led_cfg cfg = { .mode = 1 };
ioctl(fd, LED_CONFIG, &cfg);                   // 设置并获取
```

---

✅ 总结：

* `_IO`：无数据
* `_IOR`：内核 → 用户
* `_IOW`：用户 → 内核
* `_IOWR`：双向传输

这样设计的好处是 **cmd 本身携带了方向、类型、大小信息**，驱动和应用程序之间就能保持一致。

